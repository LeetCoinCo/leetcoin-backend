CREATE DATABASE prod;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'question_difficulty') THEN
        CREATE TYPE question_difficulty AS
        ENUM(
            'easy',
            'medium',
            'hard'
        );
    END IF;
END$$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'code_language') THEN
        CREATE TYPE code_language AS
            ENUM('substrate_rust');
    END IF;
END$$;

DO $$
BEGIN
    IF NOT EXISTS (SELECT 1 FROM pg_type WHERE typname = 'question_submission_status') THEN
        CREATE TYPE question_submission_status AS
            ENUM('initial', 'failed_to_compile', 'failed_tests', 'pending', 'success', 'system_error');
    END IF;
END$$;

CREATE TABLE IF NOT EXISTS questions
(
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone,
    name text,
    title text,
    description text,
    difficulty question_difficulty,
    frequency integer,
    rating integer,
    metadata jsonb,
    CONSTRAINT questions_unique_name UNIQUE(name)
);

CREATE TABLE IF NOT EXISTS users
(
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone,
    username text,
    email text,
    password text,
    metadata jsonb,
    CONSTRAINT users_unique_username UNIQUE(username),
    CONSTRAINT users_unique_email UNIQUE(email)
);

CREATE TABLE IF NOT EXISTS question_submissions
(
    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),
    user_id uuid NOT NULL,
    question_id uuid NOT NULL,
    created_at timestamp with time zone DEFAULT now(),
    updated_at timestamp with time zone DEFAULT now(),
    deleted_at timestamp with time zone,
    submission text,
    language code_language,
    status question_submission_status,
    results jsonb,
    CONSTRAINT FK_question_question_submissions FOREIGN KEY(question_id) REFERENCES questions(id),
    CONSTRAINT FK_user_question_submissions FOREIGN KEY(user_id) REFERENCES users(id)
);

INSERT INTO users (id, username, email, password, metadata)
VALUES ('ab4e5b77-45be-4d19-915b-517c39437e3d', 'example-user-1', 'email@email.com', '123', '{}');

INSERT INTO questions (id, name, title, description, difficulty, frequency, rating, metadata) 
VALUES ('bdb9334a-d703-11ed-afa1-0242ac120002', 'simple-storage', 'Simple Storage', 'Create a simple storage smart contract that stores a single unsigned 32-bit integer. The contract should have a `get` function to retrieve the stored value and a `set` function to update the stored value.', 'easy', 60, 4.5, '{"starterCode": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod simple_storage {\n    #[ink(storage)]\n    pub struct SimpleStorage {\n        // TODO, add your code here\n    }\n    impl SimpleStorage {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            // TODO, add your code here\n        }\n        // TODO, add your functions here\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        use ink_lang as ink;\n\n        #[ink::test]\n        fn test_get_and_set() {\n            let mut simple_storage = SimpleStorage::new();\n            assert_eq!(simple_storage.get(), None);\n\n            let new_value = 42;\n            simple_storage.set(new_value);\n            assert_eq!(simple_storage.get(), Some(new_value));\n        }\n    }\n}\n"}, "codeSolution": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod simple_storage {\n    #[ink(storage)]\n    pub struct SimpleStorage {\n        value: ink_storage::collections::HashMap<AccountId, u32>,\n    }\n\n    impl SimpleStorage {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self {\n                value: Default::default(),\n            }\n        }\n\n        #[ink(message)]\n        pub fn get(&self) -> Option<u32> {\n            self.value.get(&self.env().caller()).copied()\n        }\n\n        #[ink(message)]\n        pub fn set(&mut self, value: u32) {\n            self.value.insert(self.env().caller(), value);\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        use ink_lang as ink;\n\n        #[ink::test]\n        fn test_get_and_set() {\n            let mut simple_storage = SimpleStorage::new();\n            assert_eq!(simple_storage.get(), None);\n\n            let new_value = 42;\n            simple_storage.set(new_value);\n            assert_eq!(simple_storage.get(), Some(new_value));\n        }\n    }\n}\n"}, "category": "Ink!", "tags": ["smart contract", "storage"]}');

INSERT INTO questions (id, name, title, description, difficulty, frequency, rating, metadata) 
VALUES ('e9d2b4c0-d703-11ed-afa1-0242ac120002', 'counter', 'Counter', 'Create a Counter smart contract that allows users to increment and decrement a counter value. The contract should have `increment` and `decrement` functions, and a `get` function to retrieve the current value of the counter.', 'easy', 50, 4, '{"starterCode": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod counter {\n    #[ink(storage)]\n    pub struct Counter {\n        // TODO, add your code here\n    }\n    impl Counter {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            // TODO, add your code here\n        }\n        // TODO, add your functions here\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        use ink_lang as ink;\n\n        #[ink::test]\n        fn test_increment() {\n            let mut counter = Counter::new();\n            assert_eq!(counter.get(), 0);\n\n            counter.increment();\n            assert_eq!(counter.get(), 1);\n\n            counter.increment();\n            assert_eq!(counter.get(), 2);\n        }\n\n        #[ink::test]\n        fn test_decrement() {\n            let mut counter = Counter::new();\n            assert_eq!(counter.get(), 0);\n\n            counter.decrement();\n            assert_eq!(counter.get(), -1);\n\n            counter.decrement();\n            assert_eq!(counter.get(), -2);\n        }\n\n        #[ink::test]\n        fn test_increment_and_decrement() {\n            let mut counter = Counter::new();\n            assert_eq!(counter.get(), 0);\n\n            counter.increment();\n            assert_eq!(counter.get(), 1);\n\n            counter.decrement();\n            assert_eq!(counter.get(), 0);\n        }\n    }\n\n}\n"}, "codeSolution": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod counter {\n    #[ink(storage)]\n    pub struct Counter {\n        value: i32,\n    }\n    impl Counter {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self { value: 0 }\n        }\n\n        #[ink(message)]\n        pub fn get(&self) -> i32 {\n            self.value\n        }\n\n        #[ink(message)]\n        pub fn increment(&mut self) {\n            self.value += 1;\n        }\n\n        #[ink(message)]\n        pub fn decrement(&mut self) {\n            self.value -= 1;\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        use ink_lang as ink;\n\n        #[ink::test]\n        fn test_increment() {\n            let mut counter = Counter::new();\n            assert_eq!(counter.get(), 0);\n\n            counter.increment();\n            assert_eq!(counter.get(), 1);\n\n            counter.increment();\n            assert_eq!(counter.get(), 2);\n        }\n\n        #[ink::test]\n        fn test_decrement() {\n            let mut counter = Counter::new();\n            assert_eq!(counter.get(), 0);\n\n            counter.decrement();\n            assert_eq!(counter.get(), -1);\n\n            counter.decrement();\n            assert_eq!(counter.get(), -2);\n        }\n\n        #[ink::test]\n        fn test_increment_and_decrement() {\n            let mut counter = Counter::new();\n            assert_eq!(counter.get(), 0);\n\n            counter.increment();\n            assert_eq!(counter.get(), 1);\n\n            counter.decrement();\n            assert_eq!(counter.get(), 0);\n        }\n    }\n}\n"}, "category": "Ink!", "tags": ["smart contract", "counter"]}');

INSERT INTO questions (id, name, title, description, difficulty, frequency, rating, metadata) 
VALUES ('24f5a5d2-d703-11ed-afa1-0242ac120002', 'simple-token', 'Simple Token', 'Create a simple token smart contract that allows users to mint, transfer, and check their token balance. Implement `mint`, `transfer`, and `get_balance` functions.', 'med', 70, 4.5, '{"starterCode": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod simple_token {\n    #[ink(storage)]\n    pub struct SimpleToken {\n        balances: ink_prelude::collections::HashMap<AccountId, Balance>,\n    }\n    // Add your implementation here\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n    \n        use ink_lang as ink;\n    \n        #[ink::test]\n        fn test_mint() {\n            let mut token = SimpleToken::new();\n            let initial_balance = token.balance_of(AccountId::from([0x1; 32]));\n            assert_eq!(initial_balance, 0);\n    \n            let amount = 100;\n            let to = AccountId::from([0x2; 32]);\n            token.mint(to, amount);\n            assert_eq!(token.balance_of(to), amount);\n    \n            let transfer_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"Transfer\"))\n                .expect(\"no transfer event was emitted\");\n            assert_eq!(transfer_event.event, \"Transfer\");\n            assert_eq!(transfer_event.args[0].clone().into_account_id(), None);\n            assert_eq!(transfer_event.args[1].clone().into_account_id(), Some(to));\n            assert_eq!(transfer_event.args[2].clone().into_balance(), amount);\n        }\n    \n        #[ink::test]\n        fn test_transfer() {\n            let mut token = SimpleToken::new();\n            let sender = AccountId::from([0x1; 32]);\n            let recipient = AccountId::from([0x2; 32]);\n            let amount = 100;\n            token.mint(sender, amount);\n    \n            let transfer_success = token.transfer(recipient, amount);\n            assert!(transfer_success);\n            assert_eq!(token.balance_of(sender), 0);\n            assert_eq!(token.balance_of(recipient), amount);\n    \n            let transfer_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"Transfer\"))\n                .expect(\"no transfer event was emitted\");\n            assert_eq!(transfer_event.event, \"Transfer\");\n            assert_eq!(transfer_event.args[0].clone().into_account_id(), Some(sender));\n            assert_eq!(transfer_event.args[1].clone().into_account_id(), Some(recipient));\n            assert_eq!(transfer_event.args[2].clone().into_balance(), amount);\n        }\n    \n        #[ink::test]\n        fn test_insufficient_balance_transfer() {\n            let mut token = SimpleToken::new();\n            let sender = AccountId::from([0x1; 32]);\n            let recipient = AccountId::from([0x2; 32]);\n            let amount = 100;\n            token.mint(sender, amount);\n    \n            let transfer_success = token.transfer(recipient, amount + 1);\n            assert!(!transfer_success);\n            assert_eq!(token.balance_of(sender), amount);\n            assert_eq!(token.balance_of(recipient), 0);\n    \n            let emitted_events = ink_env::test::emitted_events();\n            assert_eq!(emitted_events.len(), 0);\n        }\n    \n        #[ink::test]\n        fn test_balance_of() {\n            let mut token = SimpleToken::new();\n            let account = AccountId::from([0x1; 32]);\n            let amount = 100;\n            token.mint(account, amount);\n    \n            assert_eq!(token.balance_of(account), amount);\n        }\n    }\n}\n"}, "codeSolution": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod simple_token {\n    use ink_prelude::vec::Vec;\n\n    #[ink(storage)]\n    pub struct SimpleToken {\n        balances: ink_prelude::collections::HashMap<AccountId, Balance>,\n    }\n\n    #[ink(event)]\n    pub struct Transfer {\n        #[ink(topic)]\n        from: Option<AccountId>,\n        #[ink(topic)]\n        to: Option<AccountId>,\n        value: Balance,\n    }\n\n    impl SimpleToken {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self {\n                balances: Default::default(),\n            }\n        }\n\n        #[ink(message)]\n        pub fn mint(&mut self, to: AccountId, amount: Balance) {\n            let sender = self.env().caller();\n            self.balances\n                .entry(to)\n                .and_modify(|balance| *balance += amount)\n                .or_insert(amount);\n            self.env().emit_event(Transfer {\n                from: None,\n                to: Some(to),\n                value: amount,\n            });\n        }\n\n        #[ink(message)]\n        pub fn transfer(&mut self, to: AccountId, amount: Balance) -> bool {\n            let sender = self.env().caller();\n            let sender_balance = self.balance_of(sender);\n            if sender_balance < amount {\n                return false;\n            }\n            self.balances.insert(sender, sender_balance - amount);\n            self.balances\n                .entry(to)\n                .and_modify(|balance| *balance += amount)\n                .or_insert(amount);\n            self.env().emit_event(Transfer {\n                from: Some(sender),\n                to: Some(to),\n                value: amount,\n            });\n            true\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, owner: AccountId) -> Balance {\n            self.balances.get(&owner).cloned().unwrap_or(0)\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n    \n        use ink_lang as ink;\n    \n        #[ink::test]\n        fn test_mint() {\n            let mut token = SimpleToken::new();\n            let initial_balance = token.balance_of(AccountId::from([0x1; 32]));\n            assert_eq!(initial_balance, 0);\n    \n            let amount = 100;\n            let to = AccountId::from([0x2; 32]);\n            token.mint(to, amount);\n            assert_eq!(token.balance_of(to), amount);\n    \n            let transfer_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"Transfer\"))\n                .expect(\"no transfer event was emitted\");\n            assert_eq!(transfer_event.event, \"Transfer\");\n            assert_eq!(transfer_event.args[0].clone().into_account_id(), None);\n            assert_eq!(transfer_event.args[1].clone().into_account_id(), Some(to));\n            assert_eq!(transfer_event.args[2].clone().into_balance(), amount);\n        }\n    \n        #[ink::test]\n        fn test_transfer() {\n            let mut token = SimpleToken::new();\n            let sender = AccountId::from([0x1; 32]);\n            let recipient = AccountId::from([0x2; 32]);\n            let amount = 100;\n            token.mint(sender, amount);\n    \n            let transfer_success = token.transfer(recipient, amount);\n            assert!(transfer_success);\n            assert_eq!(token.balance_of(sender), 0);\n            assert_eq!(token.balance_of(recipient), amount);\n    \n            let transfer_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"Transfer\"))\n                .expect(\"no transfer event was emitted\");\n            assert_eq!(transfer_event.event, \"Transfer\");\n            assert_eq!(transfer_event.args[0].clone().into_account_id(), Some(sender));\n            assert_eq!(transfer_event.args[1].clone().into_account_id(), Some(recipient));\n            assert_eq!(transfer_event.args[2].clone().into_balance(), amount);\n        }\n    \n        #[ink::test]\n        fn test_insufficient_balance_transfer() {\n            let mut token = SimpleToken::new();\n            let sender = AccountId::from([0x1; 32]);\n            let recipient = AccountId::from([0x2; 32]);\n            let amount = 100;\n            token.mint(sender, amount);\n    \n            let transfer_success = token.transfer(recipient, amount + 1);\n            assert!(!transfer_success);\n            assert_eq!(token.balance_of(sender), amount);\n            assert_eq!(token.balance_of(recipient), 0);\n    \n            let emitted_events = ink_env::test::emitted_events();\n            assert_eq!(emitted_events.len(), 0);\n        }\n    \n        #[ink::test]\n        fn test_balance_of() {\n            let mut token = SimpleToken::new();\n            let account = AccountId::from([0x1; 32]);\n            let amount = 100;\n            token.mint(account, amount);\n    \n            assert_eq!(token.balance_of(account), amount);\n        }\n    }\n}\n"}, "category": "Ink!", "tags": ["smart contract", "token"]}');

INSERT INTO questions (id, name, title, description, difficulty, frequency, rating, metadata) 
VALUES ('5da2b7da-d703-11ed-afa1-0242ac120002', 'voting', 'Voting', 'Create a voting smart contract that allows users to propose options and vote on them. Implement propose_option, vote, and get_results functions. The contract should prevent users from voting more than once.', 'med', 40, 4.2, '{"starterCode": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod voting {\n    #[ink(storage)]\n    pub struct Voting {\n    options: ink_prelude::collections::HashMap<u32, (String, u32)>,\n    voters: ink_prelude::collections::HashMap<AccountId, bool>,\n    }\n    // Add your implementation here\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n    \n        use ink_lang as ink;\n    \n        #[ink::test]\n        fn test_propose_option() {\n            let mut voting = Voting::new();\n            let option_name = \"Option 1\".to_string();\n            voting.propose_option(option_name.clone());\n    \n            let options = voting.get_options();\n            assert_eq!(options.len(), 1);\n            let (name, count) = options[0];\n            assert_eq!(name, option_name);\n            assert_eq!(count, 0);\n    \n            let propose_option_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"ProposeOption\"))\n                .expect(\"no ProposeOption event was emitted\");\n            assert_eq!(propose_option_event.event, \"ProposeOption\");\n            assert_eq!(propose_option_event.args[0].clone().into_string().unwrap(), option_name);\n        }\n    \n        #[ink::test]\n        fn test_vote() {\n            let mut voting = Voting::new();\n            let option_name = \"Option 1\".to_string();\n            voting.propose_option(option_name.clone());\n    \n            let voter = AccountId::from([0x1; 32]);\n            let vote_success = voting.vote(0, {ink_env::test::Call::new(voter, 0)});\n            assert!(vote_success);\n            assert!(voting.has_voted(voter));\n            assert_eq!(voting.get_option_count(0), 1);\n    \n            let vote_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"Vote\"))\n                .expect(\"no Vote event was emitted\");\n            assert_eq!(vote_event.event, \"Vote\");\n            assert_eq!(vote_event.args[0].clone().into_account_id(), Some(voter));\n            assert_eq!(vote_event.args[1].clone().into_u32(), 0);\n        }\n    \n        #[ink::test]\n        fn test_vote_twice() {\n            let mut voting = Voting::new();\n            let option_name = \"Option 1\".to_string();\n            voting.propose_option(option_name.clone());\n    \n            let voter = AccountId::from([0x1; 32]);\n            let vote_success = voting.vote(0, {ink_env::test::Call::new(voter, 0)});\n            assert!(vote_success);\n            assert!(voting.has_voted(voter));\n            assert_eq!(voting.get_option_count(0), 1);\n    \n            let vote_success = voting.vote(0, {ink_env::test::Call::new(voter, 0)});\n            assert!(!vote_success);\n            assert!(voting.has_voted(voter));\n            assert_eq!(voting.get_option_count(0), 1);\n    \n            let emitted_events = ink_env::test::emitted_events();\n            assert_eq!(emitted_events.len(), 1);\n        }\n    \n        #[ink::test]\n        fn test_get_results() {\n            let mut voting = Voting::new();\n            let option_name_1 = \"Option 1\".to_string();\n            let option_name_2 = \"Option 2\".to_string();\n            voting.propose_option(option_name_1.clone());\n            voting.propose_option(option_name_2.clone());\n    \n            let voter_1 = AccountId::from([0x1; 32]);\n            let voter_2 = AccountId::from([0x2; 32]);\n            let voter_3 = AccountId::from([0x3; 32]);\n            voting.vote(0, {ink_env::test::Call::new(voter_1, 0\n            voting.vote(1, {ink_env::test::Call::new(voter_1, 0)});\n            voting.vote(1, {ink_env::test::Call::new(voter_2, 0)});\n            voting.vote(1, {ink_env::test::Call::new(voter_3, 0)});\n            voting.vote(1, {ink_env::test::Call::new(voter_3, 0)});\n            voting.vote(1, {ink_env::test::Call::new(voter_3, 0)});\n        \n            let results = voting.get_results();\n            assert_eq!(results.len(), 2);\n            let (name_1, count_1) = results[0];\n            let (name_2, count_2) = results[1];\n            assert_eq!(name_1, option_name_1);\n            assert_eq!(name_2, option_name_2);\n            assert_eq!(count_1, 1);\n            assert_eq!(count_2, 4);\n        \n            let get_results_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"GetResults\"))\n                .expect(\"no GetResults event was emitted\");\n            assert_eq!(get_results_event.event, \"GetResults\");\n            assert_eq!(get_results_event.args[0].clone().into_vec().unwrap().len(), 2);\n        }\n}\n"}, "codeSolution": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod voting {\n    use ink_prelude::vec::Vec;\n\n    #[ink(storage)]\n    pub struct Voting {\n        options: ink_prelude::collections::Vec<(String, u32)>,\n        voters: ink_prelude::collections::HashMap<AccountId, bool>,\n    }\n\n    #[ink(event)]\n    pub struct ProposeOption {\n        #[ink(topic)]\n        name: String,\n    }\n\n    #[ink(event)]\n    pub struct Vote {\n        #[ink(topic)]\n        voter: AccountId,\n        #[ink(topic)]\n        option_index: u32,\n    }\n\n    #[ink(event)]\n    pub struct GetResults {\n        results: Vec<(String, u32)>,\n    }\n\n    impl Voting {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self {\n                options: ink_prelude::collections::Vec::new(),\n                voters: ink_prelude::collections::HashMap::new(),\n            }\n        }\n\n        #[ink(message)]\n        pub fn propose_option(&mut self, name: String) {\n            self.options.push((name.clone(), 0));\n            self.env().emit_event(ProposeOption { name });\n        }\n\n        #[ink(message)]\n        pub fn vote(&mut self, option_index: u32) -> bool {\n            let sender = self.env().caller();\n            if self.voters.contains_key(&sender) {\n                return false;\n            }\n            if let Some((name, count)) = self.options.get_mut(option_index as usize) {\n                *count += 1;\n                self.voters.insert(sender, true);\n                self.env().emit_event(Vote {\n                    voter: sender,\n                    option_index,\n                });\n                return true;\n            }\n            false\n        }\n\n        #[ink(message)]\n        pub fn has_voted(&self, voter: AccountId) -> bool {\n            self.voters.contains_key(&voter)\n        }\n\n        #[ink(message)]\n        pub fn get_option_count(&self, option_index: u32) -> u32 {\n            if let Some((_, count)) = self.options.get(option_index as usize) {\n                *count\n            } else {\n                0\n            }\n        }\n\n        #[ink(message)]\n        pub fn get_options(&self) -> Vec<(String, u32)> {\n            self.options.clone()\n        }\n\n        #[ink(message)]\n        pub fn get_results(&self) -> Vec<(String, u32)> {\n            self.options.clone()\n        }\n\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        use ink_lang as ink;\n\n        #[ink::test]\n        fn test_propose_option() {\n            let mut voting = Voting::new();\n            let option_name = \"Option 1\".to_string();\n            voting.propose_option(option_name.clone());\n\n            let options = voting.get_options();\n            assert_eq!(options.len(), 1);\n            let (name, count) = options[0];\n            assert_eq!(name, option_name);\n            assert_eq!(count, 0);\n\n            let propose_option_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"ProposeOption\"))\n                .expect(\"no ProposeOption event was emitted\");\n            assert_eq!(propose_option_event.event, \"ProposeOption\");\n            assert_eq!(propose_option_event.args[0].clone().into_string().unwrap(), option_name);\n        }\n\n        #[ink::test]\n        fn test_vote() {\n            let mut voting = Voting::new();\n            let option_name = \"Option 1\".to_string();\n            voting.propose_option(option_name.clone());\n\n            let voter = AccountId::from([0x1; 32]);\n            let vote_success = voting.vote(0, {ink_env::test::Call::new(voter, 0)});\n            assert!(vote_success);\n            assert!(voting.has_voted(voter));\n            assert_eq!(voting.get_option_count(0), 1);\n\n            let vote_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"Vote\"))\n                .expect(\"no Vote event was emitted\");\n            assert_eq!(vote_event.event, \"Vote\");\n            assert_eq!(vote_event.args[0].clone().into_account_id(), Some(voter));\n            assert_eq!(vote_event.args[1].clone().into_u32(), 0);\n        }\n\n        #[ink::test]\n        fn test_vote_twice() {\n            let mut voting = Voting::new();\n            let option_name = \"Option 1\".to_string();\n            voting.propose_option(option_name.clone());\n\n            let voter = AccountId::from([0x1; 32]);\n            let vote_success = voting.vote(0, {ink_env::test::Call::new(voter, 0)});\n            assert!(vote_success);\n            assert!(voting.has_voted(voter));\n            assert_eq!(voting.get_option_count(0), 1);\n\n            let vote_success = voting.vote(0, {ink_env::test::Call::new(voter, 0)});\n            assert!(!vote_success);\n            assert!(voting.has_voted(voter));\n            assert_eq!(voting.get_option_count(0), 1);\n\n            let emitted_events = ink_env::test::emitted_events();\n            assert_eq!(emitted_events.len(), 1);\n        }\n\n        #[ink::test]\n        fn test_get_results() {\n            let mut voting = Voting::new();\n            let option_name_1 = \"Option 1\".to_string();\n            let option_name_2 = \"Option 2\".to_string();\n            voting.propose_option(option_name_1.clone());\n            voting.propose_option(option_name_2.clone());\n\n            let voter_1 = AccountId::from([0x1; 32]);\n            let voter_2 = AccountId::from([0x2; 32]);\n            let voter_3 = AccountId::from([0x3; 32]);\n            voting.vote(1, {ink_env::test::Call::new(voter_1, 0)});\n            voting.vote(1, {ink_env::test::Call::new(voter_2, 0)});\n            voting.vote(1, {ink_env::test::Call::new(voter_3, 0)});\n            voting.vote(1, {ink_env::test::Call::new(voter_3, 0)});\n            voting.vote(1, {ink_env::test::Call::new(voter_3, 0)});\n\n            let results = voting.get_results();\n            assert_eq!(results.len(), 2);\n            let (name_1, count_1) = results[0];\n            let (name_2, count_2) = results[1];\n            assert_eq!(name_1, option_name_1);\n            assert_eq!(name_2, option_name_2);\n            assert_eq!(count_1, 1);\n            assert_eq!(count_2, 4);\n\n            let get_results_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"GetResults\"))\n                .expect(\"no GetResults event was emitted\");\n            assert_eq!(get_results_event.event, \"GetResults\");\n            assert_eq!(get_results_event.args[0].clone().into_vec().unwrap().len(), 2);\n        }\n    }\n}\n"}, "category": "Ink!", "tags": ["smart contract", "voting"]}');

INSERT INTO questions (id, name, title, description, difficulty, frequency, rating, metadata)
VALUES ('97bca69a-d703-11ed-afa1-0242ac120002', 'escrow', 'Escrow', 'Create an escrow smart contract that allows two parties to lock funds and release them upon agreement. Implement lock_funds, release_funds, and refund_funds functions.', 'hard', 30, 4.8, '{"starterCode": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod escrow {\n    #[ink(storage)]\n    pub struct Escrow {\n        seller: AccountId,\n        buyer: AccountId,\n        amount: Balance,\n        status: EscrowStatus,\n    }\n    // Add your implementation here\n    \n    #[cfg(test)]\n    mod tests {\n        use super::*;\n    \n        use ink_lang as ink;\n    \n        #[ink::test]\n        fn test_lock_funds() {\n            let mut escrow = Escrow::new(AccountId::from([0x1; 32]), AccountId::from([0x2; 32]), 100);\n            assert_eq!(escrow.get_status(), EscrowStatus::Locked);\n    \n            let lock_funds_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"LockFunds\"))\n                .expect(\"no LockFunds event was emitted\");\n            assert_eq!(lock_funds_event.event, \"LockFunds\");\n            assert_eq!(lock_funds_event.args[0].clone().into_account_id(), AccountId::from([0x1; 32]));\n            assert_eq!(lock_funds_event.args[1].clone().into_account_id(), AccountId::from([0x2; 32]));\n            assert_eq!(lock_funds_event.args[2].clone().into_balance(), 100);\n        }\n    \n        #[ink::test]\n        fn test_release_funds() {\n            let mut escrow = Escrow::new(AccountId::from([0x1; 32]), AccountId::from([0x2; 32]), 100);\n            escrow.release_funds();\n            assert_eq!(escrow.get_status(), EscrowStatus::Released);\n    \n            let release_funds_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"ReleaseFunds\"))\n                .expect(\"no ReleaseFunds event was emitted\");\n            assert_eq!(release_funds_event.event, \"ReleaseFunds\");\n            assert_eq!(release_funds_event.args[0].clone().into_account_id(), AccountId::from([0x1; 32]));\n            assert_eq!(release_funds_event.args[1].clone().into_account_id(), AccountId::from([0x2; 32]));\n            assert_eq!(release_funds_event.args[2].clone().into_balance(), 100);\n        }\n    \n        #[ink::test]\n        fn test_refund_funds() {\n            let mut escrow = Escrow::new(AccountId::from([0x1; 32]), AccountId::from([0x2; 32]), 100);\n            escrow.refund_funds();\n            assert_eq!(escrow.get_status(), EscrowStatus::Refunded);\n    \n            let refund_funds_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"RefundFunds\"))\n                .expect(\"no RefundFunds event was emitted\");\n            assert_eq!(refund_funds_event.event, \"RefundFunds\");\n            assert_eq!(refund_funds_event.args[0].clone().into_account_id(), AccountId::from([0x1; 32]));\n            assert_eq!(refund_funds_event.args[1].clone().into_account_id(), AccountId::from([0x2; 32]));\n            assert_eq!(refund_funds_event.args[2].clone().into_balance(), 100);\n        }\n    \n        #[ink::test]\n        fn test_release_funds_unauthorized() {\n            let mut escrow = Escrow::new(AccountId::from([0x1; 32]), AccountId::from([0x2; 32]), 100);\n            assert_eq!(escrow.get_status(), EscrowStatus::Locked);\n    \n            // try to release funds from a non-buyer account\n            let unauthorized_caller = AccountId::from([0\n            // check that the status has not changed\n            assert_eq!(escrow.get_status(), EscrowStatus::Locked);\n        \n            // check that no events have been emitted\n            let emitted_events = ink_env::test::emitted_events();\n            assert!(emitted_events.iter().all(|event| event.event != \"ReleaseFunds\"));\n            assert!(emitted_events.iter().all(|event| event.event != \"RefundFunds\"));\n        }\n        \n        #[ink::test]\n        fn test_refund_funds_unauthorized() {\n            let mut escrow = Escrow::new(AccountId::from([0x1; 32]), AccountId::from([0x2; 32]), 100);\n            assert_eq!(escrow.get_status(), EscrowStatus::Locked);\n        \n            // try to refund funds from a non-seller account\n            let unauthorized_caller = AccountId::from([0x3; 32]);\n            assert_eq!(\n                escrow.refund_funds_with_call(\n                    ink_env::test::Call::new(unauthorized_caller, 0)\n                ),\n                Err(Error::Unauthorized)\n            );\n        \n            // check that the status has not changed\n            assert_eq!(escrow.get_status(), EscrowStatus::Locked);\n        \n            // check that no events have been emitted\n            let emitted_events = ink_env::test::emitted_events();\n            assert!(emitted_events.iter().all(|event| event.event != \"ReleaseFunds\"));\n            assert!(emitted_events.iter().all(|event| event.event != \"RefundFunds\"));\n        }\n\n\n}\n"}, "codeSolution": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod escrow {\n    use ink_prelude::collections::HashMap;\n\n    #[ink(storage)]\n    pub struct Escrow {\n        seller: AccountId,\n        buyer: AccountId,\n        amount: Balance,\n        status: EscrowStatus,\n        authorized_callers: HashMap<AccountId, bool>,\n    }\n\n    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n    #[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\n    pub enum EscrowStatus {\n        Locked,\n        Released,\n        Refunded,\n    }\n\n    #[ink(event)]\n    pub struct LockFunds {\n        #[ink(topic)]\n        seller: AccountId,\n        #[ink(topic)]\n        buyer: AccountId,\n        #[ink(topic)]\n        amount: Balance,\n    }\n\n    #[ink(event)]\n    pub struct ReleaseFunds {\n        #[ink(topic)]\n        seller: AccountId,\n        #[ink(topic)]\n        buyer: AccountId,\n        #[ink(topic)]\n        amount: Balance,\n    }\n\n    #[ink(event)]\n    pub struct RefundFunds {\n        #[ink(topic)]\n        seller: AccountId,\n        #[ink(topic)]\n        buyer: AccountId,\n        #[ink(topic)]\n        amount: Balance,\n    }\n\n    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n    #[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\n    pub enum Error {\n        Unauthorized,\n    }\n\n    impl Escrow {\n        #[ink(constructor)]\n        pub fn new(seller: AccountId, buyer: AccountId, amount: Balance) -> Self {\n            Self {\n                seller,\n                buyer,\n                amount,\n                status: EscrowStatus::Locked,\n                authorized_callers: HashMap::new(),\n            }\n        }\n\n        #[ink(message)]\n        pub fn lock_funds(&mut self) {\n            self.env().emit_event(LockFunds {\n                seller: self.seller,\n                buyer: self.buyer,\n                amount: self.amount,\n            });\n        }\n\n        #[ink(message)]\n        pub fn release_funds(&mut self) -> Result<(), Error> {\n            let caller = self.env().caller();\n            if !self.authorized_callers.contains_key(&caller) || caller != self.buyer {\n                return Err(Error::Unauthorized);\n            }\n            self.env().transfer(self.seller, self.amount)?;\n            self.status = EscrowStatus::Released;\n            self.env().emit_event(ReleaseFunds {\n                seller: self.seller,\n                buyer: self.buyer,\n                amount: self.amount,\n            });\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn refund_funds(&mut self) -> Result<(), Error> {\n            let caller = self.env().caller();\n            if !self.authorized_callers.contains_key(&caller) || caller != self.seller {\n                return Err(Error::Unauthorized);\n            }\n            self.env().transfer(self.buyer, self.amount)?;\n            self.status = EscrowStatus::Refunded;\n            self.env().emit_event(RefundFunds {\n                seller: self.seller,\n                buyer: self.buyer,\n                amount: self.amount,\n            });\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn get_status(&self) -> EscrowStatus {\n            self.status\n        }\n\n        #[ink(message)]\n        pub fn authorize_caller(&mut self, caller: AccountId) {\n            let _ = self.authorized_callers.insert(caller, true);\n        }\n\n        #[ink(message)]\n        pub fn revoke_authorization(&mut self, caller: AccountId) {\n            let _ = self.authorized_callers.take(&caller);\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n\n        use ink_lang as ink;\n\n        #[ink::test]\n        fn test_lock_funds() {\n            let mut escrow = Escrow::new(AccountId::from([0x1; 32]), AccountId::from([0x2; 32]), 100);\n            assert_eq!(escrow.get_status(), EscrowStatus::Locked);\n\n            let lock_funds_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"LockFunds\"))\n                .expect(\"no LockFunds event was emitted\");\n            assert_eq!(lock_funds_event.event, \"LockFunds\");\n            assert_eq!(lock_funds_event.args[0].clone().into_account_id(), AccountId::from([0x1; 32]));\n            assert_eq!(lock_funds_event.args[1].clone().into_account_id(), AccountId::from([0x2; 32]));\n            assert_eq!(lock_funds_event.args[2].clone().into_balance(), 100);\n        }\n\n        #[ink::test]\n        fn test_release_funds() {\n            let mut escrow = Escrow::new(AccountId::from([0x1; 32]), AccountId::from([0x2; 32]), 100);\n            escrow.release_funds();\n            assert_eq!(escrow.get_status(), EscrowStatus::Released);\n\n            let release_funds_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"ReleaseFunds\"))\n                .expect(\"no ReleaseFunds event was emitted\");\n            assert_eq!(release_funds_event.event, \"ReleaseFunds\");\n            assert_eq!(release_funds_event.args[0].clone().into_account_id(), AccountId::from([0x1; 32]));\n            assert_eq!(release_funds_event.args[1].clone().into_account_id(), AccountId::from([0x2; 32]));\n            assert_eq!(release_funds_event.args[2].clone().into_balance(), 100);\n        }\n\n        #[ink::test]\n        fn test_refund_funds() {\n            let mut escrow = Escrow::new(AccountId::from([0x1; 32]), AccountId::from([0x2; 32]), 100);\n            escrow.refund_funds();\n            assert_eq!(escrow.get_status(), EscrowStatus::Refunded);\n\n            let refund_funds_event = ink_env::test::emitted_events()\n                .find(|event| matches!(event.event, \"RefundFunds\"))\n                .expect(\"no RefundFunds event was emitted\");\n            assert_eq!(refund_funds_event.event, \"RefundFunds\");\n            assert_eq!(refund_funds_event.args[0].clone().into_account_id(), AccountId::from([0x1; 32]));\n            assert_eq!(refund_funds_event.args[1].clone().into_account_id(), AccountId::from([0x2; 32]));\n            assert_eq!(refund_funds_event.args[2].clone().into_balance(), 100);\n        }\n\n        #[ink::test]\n        fn test_refund_funds_unauthorized() {\n            let mut escrow = Escrow::new(AccountId::from([0x1; 32]), AccountId::from([0x2; 32]), 100);\n            assert_eq!(escrow.get_status(), EscrowStatus::Locked);\n\n            // try to refund funds from a non-seller account\n            let unauthorized_caller = AccountId::from([0x3; 32]);\n            assert_eq!(\n                escrow.refund_funds_with_call(\n                    ink_env::test::Call::new(unauthorized_caller, 0)\n                ),\n                Err(Error::Unauthorized)\n            );\n\n            // check that the status has not changed\n            assert_eq!(escrow.get_status(), EscrowStatus::Locked);\n\n            // check that no events have been emitted\n            let emitted_events = ink_env::test::emitted_events();\n            assert!(emitted_events.iter().all(|event| event.event != \"ReleaseFunds\"));\n            assert!(emitted_events.iter().all(|event| event.event != \"RefundFunds\"));\n        }\n    }\n}\n"}, "category": "Ink!", "tags": ["smart contract", "escrow"]}');

INSERT INTO questions (id, name, title, description, difficulty, frequency, rating, metadata)
VALUES ('d300b862-d703-11ed-afa1-0242ac120002', 'multi-signature-wallet', 'Multi-Signature Wallet', 'Create a multi-signature wallet smart contract that requires multiple confirmations for transactions. Implement propose_transaction, confirm_transaction, and execute_transaction functions.', 'hard', 20, 4.7, '{"starterCode": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod multisig_wallet {\n    #[ink(storage)]\n    pub struct MultisigWallet {\n        owners: ink_prelude::collections::HashMap<AccountId, bool>,\n        required_confirmations: u32,\n        transactions: ink_prelude::collections::HashMap<u32, (Hash, Balance, AccountId, u32, bool)>,\n        confirmations: ink_prelude::collections::HashMap<u32, ink_prelude::collections::HashMap<AccountId, bool>>,\n    }\n    // Add your implementation here\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n        use ink_lang as ink;\n\n        #[ink::test]\n        fn test_propose_transaction() {\n            let mut wallet = MultisigWallet::new(2);\n\n            let tx_hash = Hash::from([0x1; 32]);\n            let to = AccountId::from([0x2; 32]);\n            let value = 100;\n            let data = vec![0x3; 10];\n\n            assert_eq!(\n                wallet.propose_transaction(to, value, data.clone()),\n                Ok(0)\n            );\n\n            let tx = wallet.get_transaction(0);\n            assert_eq!(tx, Some((tx_hash, value, to, 0, false)));\n            assert_eq!(wallet.get_confirmations(0), HashMap::new());\n            assert_eq!(wallet.get_transaction_count(), 1);\n\n            let emitted_events = ink_env::test::emitted_events();\n            assert_eq!(emitted_events.count(), 1);\n            assert_eq!(\n                emitted_events\n                    .into_iter()\n                    .next()\n                    .expect(\"no events emitted\")\n                    .event,\n                \"ProposeTransaction\"\n            );\n        }\n\n        #[ink::test]\n        fn test_confirm_transaction() {\n            let mut wallet = MultisigWallet::new(2);\n\n            let tx_hash = Hash::from([0x1; 32]);\n            let to = AccountId::from([0x2; 32]);\n            let value = 100;\n            let data = vec![0x3; 10];\n            wallet.propose_transaction(to, value, data.clone()).unwrap();\n\n            let signer1 = AccountId::from([0x4; 32]);\n            let signer2 = AccountId::from([0x5; 32]);\n\n            assert_eq!(\n                wallet.confirm_transaction(0, signer1),\n                Ok(())\n            );\n            assert_eq!(wallet.get_confirmations(0), hash_map! { signer1 => true });\n            assert_eq!(wallet.is_confirmed(0), false);\n\n            assert_eq!(\n                wallet.confirm_transaction(0, signer2),\n                Ok(())\n            );\n            assert_eq!(\n                wallet.get_confirmations(0),\n                hash_map! { signer1 => true, signer2 => true }\n            );\n            assert_eq!(wallet.is_confirmed(0), true);\n\n            let emitted_events = ink_env::test::emitted_events();\n            assert_eq!(emitted_events.count(), 2);\n            let events: Vec<_> = emitted_events\n                .into_iter()\n                .map(|e| e.event)\n                .collect();\n            assert!(events.contains(&\"ConfirmTransaction\".to_string()));\n            assert!(events.contains(&\"ExecuteTransaction\".to_string()));\n        }\n\n        #[ink::test]\n        fn test_execute_transaction() {\n            let mut wallet = MultisigWallet::new(2);\n\n            let tx_hash = Hash::from([0x1; 32]);\n            let to = AccountId::from([0x2; 32]);\n            let value = 100;\n            let data = vec![0x3; 10];\n            wallet.propose_transaction(to, value, data.clone()).unwrap();\n\n            let signer1 = AccountId::from([0x4; 32]);\n            let signer2 = AccountId::from([0x5; 32]);\n            wallet.confirm_transaction(0, signer1).unwrap();\n            wallet.confirm_transaction(0, signer2).unwrap();\n\n            assert_eq!(\n                wallet.execute_transaction(0),\n                Ok(())\n            );\n            assert_eq!(wallet.get_transaction(0), Some((tx_hash, value, to, 2, true)));\n            assert_eq!(wallet.get_confirmations(0), HashMap::new());\n            assert_eq!(wallet.get_transaction_count(), 1);\n\n            let emitted_events = ink_env::test::emitted_events();\n            assert_eq!(emitted_events.count(), 2);\n            let events: Vec<_> = emitted_events\n                .into_iter()\n                .map(|e| e.event)\n                .collect();\n            assert!(events.contains(&\"ExecuteTransaction\".to_string()));\n        }\n\n        #[ink::test]\n        fn test_execute_transaction_not_enough_confirmations() {\n            let mut wallet = MultisigWallet::new(2);\n\n            let tx_hash = Hash::from([0x1; 32]);\n            let to = AccountId::from([0x2; 32]);\n            let value = 100;\n            let data = vec![0x3; 10];\n            wallet.propose_transaction(to, value, data.clone()).unwrap();\n\n            let signer1 = AccountId::from([0x4; 32]);\n            wallet.confirm_transaction(0, signer1).unwrap();\n\n            assert_eq!(\n                wallet.execute_transaction(0),\n                Err(Error::NotEnoughConfirmations)\n            );\n            assert_eq!(wallet.get_transaction(0), Some((tx_hash, value, to, 1, false)));\n            assert_eq!(\n                wallet.get_confirmations(0),\n                hash_map! { signer1 => true }\n            );\n            assert_eq!(wallet.get_transaction_count(), 1);\n\n            let emitted_events = ink_env::test::emitted_events();\n            assert_eq!(emitted_events.count(), 0);\n        }\n\n        #[ink::test]\n        fn test_execute_transaction_already_executed() {\n            let mut wallet = MultisigWallet::new(2);\n\n            let tx_hash = Hash::from([0x1; 32]);\n            let to = AccountId::from([0x2; 32]);\n            let value = 100;\n            let data = vec![0x3; 10];\n            wallet.propose_transaction(to, value, data.clone()).unwrap();\n\n            let signer1 = AccountId::from([0x4; 32]);\n            let signer2 = AccountId::from([0x5; 32]);\n            wallet.confirm_transaction(0, signer1).unwrap();\n            wallet.confirm_transaction(0, signer2).unwrap();\n            wallet.execute_transaction(0).unwrap();\n\n            assert_eq!(\n                wallet.execute_transaction(0),\n                Err(Error::AlreadyExecuted)\n            );\n            assert_eq!(wallet.get_transaction(0), Some((tx_hash, value, to, 2, true)));\n            assert_eq!(wallet.get_confirmations(0), HashMap::new());\n            assert_eq!(wallet.get_transaction_count(), 1);\n\n            let emitted_events = ink_env::test::emitted_events();\n            assert_eq!(emitted_events.count(), 1);\n            assert_eq!(\n                emitted_events\n                    .into_iter()\n                    .next()\n                    .expect(\"no events emitted\")\n                    .event,\n                \"ExecuteTransaction\"\n            );\n        }\n    }\n}\n\n"}, "codeSolution": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod multisig_wallet {\n    use ink_prelude::collections::HashMap;\n    use ink_prelude::vec::Vec;\n\n    #[ink(storage)]\n    pub struct MultisigWallet {\n        owners: HashMap<AccountId, bool>,\n        required_confirmations: u32,\n        transactions: HashMap<u32, (Hash, Balance, AccountId, u32, bool)>,\n        confirmations: HashMap<u32, HashMap<AccountId, bool>>,\n    }\n\n    impl MultisigWallet {\n        #[ink(constructor)]\n        pub fn new(required_confirmations: u32) -> Self {\n            Self {\n                owners: HashMap::new(),\n                required_confirmations,\n                transactions: HashMap::new(),\n                confirmations: HashMap::new(),\n            }\n        }\n\n        pub fn propose_transaction(\n            &mut self,\n            to: AccountId,\n            value: Balance,\n            data: Vec<u8>,\n        ) -> Result<u32, Error> {\n            let id = self.transactions.len() as u32;\n            let tx_hash = Self::hash(&to, value, &data);\n            self.transactions.insert(\n                id,\n                (tx_hash, value, to, 0, false)\n            );\n            self.confirmations.insert(id, HashMap::new());\n            self.emit_propose_transaction(id, tx_hash, to, value, data);\n            Ok(id)\n        }\n\n        pub fn confirm_transaction(\n            &mut self,\n            id: u32,\n            owner: AccountId,\n        ) -> Result<(), Error> {\n            let tx = self.transactions.get(&id).ok_or(Error::InvalidTransactionId)?;\n            let mut confirmations = self.confirmations.get(&id).ok_or(Error::InvalidTransactionId)?;\n\n            if !self.owners.contains_key(&owner) {\n                return Err(Error::Unauthorized);\n            }\n            if confirmations.contains_key(&owner) {\n                return Err(Error::AlreadyConfirmed);\n            }\n\n            confirmations.insert(owner, true);\n            self.emit_confirm_transaction(id, owner);\n\n            if self.is_confirmed(id) {\n                self.execute_transaction(id)?;\n            }\n\n            Ok(())\n        }\n\n        pub fn execute_transaction(&mut self, id: u32) -> Result<(), Error> {\n            let mut tx = self.transactions.get_mut(&id).ok_or(Error::InvalidTransactionId)?;\n            let mut confirmations = self.confirmations.remove(&id).ok_or(Error::InvalidTransactionId)?;\n\n            if tx.4 {\n                return Err(Error::AlreadyExecuted);\n            }\n            if !self.is_confirmed(id) {\n                return Err(Error::NotEnoughConfirmations);\n            }\n\n            for (owner, _) in confirmations.iter() {\n                let balance = Self::env().balance(*owner);\n                Self::env().transfer(*owner, tx.1).map_err(|_| Error::TransferFailed)?;\n            }\n\n            tx.3 = confirmations.len() as u32;\n            tx.4 = true;\n            self.emit_execute_transaction(id, tx.2, tx.1);\n\n            Ok(())\n        }\n\n        pub fn add_owner(&mut self, owner: AccountId) -> Result<(), Error> {\n            if self.owners.contains_key(&owner) {\n                return Err(Error::AlreadyOwner);\n            }\n            self.owners.insert(owner, true);\n            Ok(())\n        }\n\n        pub fn remove_owner(&mut self, owner: AccountId) -> Result<(), Error> {\n            if self.owners.len() == 1 {\n                return Err(Error::CannotRemoveLastOwner);\n            }\n            if !self.owners.contains_key(&owner) {\n                return Err(Error::NotOwner);\n            }\n            self.owners.remove(&owner);\n            Ok(())\n        }\n\n        pub fn is_confirmed(&self, id: u32) -> bool {\n            let confirmations = self.confirmations.get(&id).unwrap();\n            confirmations.len() >= self.required_confirmations as usize\n        }\n\n        pub fn get_transaction_count(&self) -> u32 {\n            self.transactions.len() as u32\n        }\n\n        pub fn get_transaction(&self, id: u32) -> Option<(Hash, Balance, AccountId, u32, bool)> {\n            self.transactions.get(&id).cloned()\n        }\n\n        pub fn get_confirmations(&self, id: u32) -> HashMap<AccountId, bool> {\n            self.confirmations.get(&id).cloned().unwrap_or_default()\n        }\n\n        fn hash(to: &AccountId, value: Balance, data: &[u8]) -> Hash {\n            Self::env().hash_of(&(to, value, data))\n        }\n    }\n\n    #[ink(event)]\n    pub struct ProposeTransaction {\n        #[ink(topic)]\n        id: u32,\n        tx_hash: Hash,\n        to: AccountId,\n        value: Balance,\n        data: Vec<u8>,\n    }\n\n    #[ink(event)]\n    pub struct ConfirmTransaction {\n        #[ink(topic)]\n        id: u32,\n        owner: AccountId,\n    }\n\n    #[ink(event)]\n    pub struct ExecuteTransaction {\n        #[ink(topic)]\n        id: u32,\n        to: AccountId,\n        value: Balance,\n    }\n\n    #[ink(event)]\n    pub struct AddOwner {\n        #[ink(topic)]\n        owner: AccountId,\n    }\n\n    #[ink(event)]\n    pub struct RemoveOwner {\n        #[ink(topic)]\n        owner: AccountId,\n    }\n\n    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n    #[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\n    pub enum Error {\n        InvalidTransactionId,\n        Unauthorized,\n        AlreadyConfirmed,\n        AlreadyExecuted,\n        NotEnoughConfirmations,\n        TransferFailed,\n        AlreadyOwner,\n        NotOwner,\n        CannotRemoveLastOwner,\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n        use ink_lang as ink;\n\n        #[ink::test]\n        fn test_propose_transaction() {\n            let mut wallet = MultisigWallet::new(2);\n\n            let tx_hash = Hash::from([0x1; 32]);\n            let to = AccountId::from([0x2; 32]);\n            let value = 100;\n            let data = vec![0x3; 10];\n\n            assert_eq!(\n                wallet.propose_transaction(to, value, data.clone()),\n                Ok(0)\n            );\n\n            let tx = wallet.get_transaction(0);\n            assert_eq!(tx, Some((tx_hash, value, to, 0, false)));\n            assert_eq!(wallet.get_confirmations(0), HashMap::new());\n            assert_eq!(wallet.get_transaction_count(), 1);\n\n            let emitted_events = ink_env::test::emitted_events();\n            assert_eq!(emitted_events.count(), 1);\n            assert_eq!(\n                emitted_events\n                    .into_iter()\n                    .next()\n                    .expect(\"no events emitted\")\n                    .event,\n                \"ProposeTransaction\"\n            );\n        }\n\n        #[ink::test]\n        fn test_confirm_transaction() {\n            let mut wallet = MultisigWallet::new(2);\n\n            let tx_hash = Hash::from([0x1; 32]);\n            let to = AccountId::from([0x2; 32]);\n            let value = 100;\n            let data = vec![0x3; 10];\n            wallet.propose_transaction(to, value, data.clone()).unwrap();\n\n            let signer1 = AccountId::from([0x4; 32]);\n            let signer2 = AccountId::from([0x5; 32]);\n\n            assert_eq!(\n                wallet.confirm_transaction(0, signer1),\n                Ok(())\n            );\n            assert_eq!(wallet.get_confirmations(0), hash_map! { signer1 => true });\n            assert_eq!(wallet.is_confirmed(0), false);\n\n            assert_eq!(\n                wallet.confirm_transaction(0, signer2),\n                Ok(())\n            );\n            assert_eq!(\n                wallet.get_confirmations(0),\n                hash_map! { signer1 => true, signer2 => true }\n            );\n            assert_eq!(wallet.is_confirmed(0), true);\n\n            let emitted_events = ink_env::test::emitted_events();\n            assert_eq!(emitted_events.count(), 2);\n            let events: Vec<_> = emitted_events\n                .into_iter()\n                .map(|e| e.event)\n                .collect();\n            assert!(events.contains(&\"ConfirmTransaction\".to_string()));\n            assert!(events.contains(&\"ExecuteTransaction\".to_string()));\n        }\n\n        #[ink::test]\n        fn test_execute_transaction() {\n            let mut wallet = MultisigWallet::new(2);\n\n            let tx_hash = Hash::from([0x1; 32]);\n            let to = AccountId::from([0x2; 32]);\n            let value = 100;\n            let data = vec![0x3; 10];\n            wallet.propose_transaction(to, value, data.clone()).unwrap();\n\n            let signer1 = AccountId::from([0x4; 32]);\n            let signer2 = AccountId::from([0x5; 32]);\n            wallet.confirm_transaction(0, signer1).unwrap();\n            wallet.confirm_transaction(0, signer2).unwrap();\n\n            assert_eq!(\n                wallet.execute_transaction(0),\n                Ok(())\n            );\n            assert_eq!(wallet.get_transaction(0), Some((tx_hash, value, to, 2, true)));\n            assert_eq!(wallet.get_confirmations(0), HashMap::new());\n            assert_eq!(wallet.get_transaction_count(), 1);\n\n            let emitted_events = ink_env::test::emitted_events();\n            assert_eq!(emitted_events.count(), 2);\n            let events: Vec<_> = emitted_events\n                .into_iter()\n                .map(|e| e.event)\n                .collect();\n            assert!(events.contains(&\"ExecuteTransaction\".to_string()));\n        }\n    }\n\n    #[ink::test]\n    fn test_execute_transaction_not_enough_confirmations() {\n        let mut wallet = MultisigWallet::new(2);\n\n        let tx_hash = Hash::from([0x1; 32]);\n        let to = AccountId::from([0x2; 32]);\n        let value = 100;\n        let data = vec![0x3; 10];\n        wallet.propose_transaction(to, value, data.clone()).unwrap();\n\n        let signer1 = AccountId::from([0x4; 32]);\n        wallet.confirm_transaction(0, signer1).unwrap();\n\n        assert_eq!(\n            wallet.execute_transaction(0),\n            Err(Error::NotEnoughConfirmations)\n        );\n        assert_eq!(wallet.get_transaction(0), Some((tx_hash, value, to, 1, false)));\n        assert_eq!(\n            wallet.get_confirmations(0),\n            hash_map! { signer1 => true }\n        );\n        assert_eq!(wallet.get_transaction_count(), 1);\n\n        let emitted_events = ink_env::test::emitted_events();\n        assert_eq!(emitted_events.count(), 0);\n    }\n\n    #[ink::test]\n    fn test_execute_transaction_already_executed() {\n        let mut wallet = MultisigWallet::new(2);\n\n        let tx_hash = Hash::from([0x1; 32]);\n        let to = AccountId::from([0x2; 32]);\n        let value = 100;\n        let data = vec![0x3; 10];\n        wallet.propose_transaction(to, value, data.clone()).unwrap();\n\n        let signer1 = AccountId::from([0x4; 32]);\n        let signer2 = AccountId::from([0x5; 32]);\n        wallet.confirm_transaction(0, signer1).unwrap();\n        wallet.confirm_transaction(0, signer2).unwrap();\n        wallet.execute_transaction(0).unwrap();\n\n        assert_eq!(\n            wallet.execute_transaction(0),\n            Err(Error::AlreadyExecuted)\n        );\n        assert_eq!(wallet.get_transaction(0), Some((tx_hash, value, to, 2, true)));\n        assert_eq!(wallet.get_confirmations(0), HashMap::new());\n        assert_eq!(wallet.get_transaction_count(), 1);\n\n        let emitted_events = ink_env::test::emitted_events();\n        assert_eq!(emitted_events.count(), 1);\n        assert_eq!(\n            emitted_events\n                .into_iter()\n                .next()\n                .expect(\"no events emitted\")\n                .event,\n            \"ExecuteTransaction\"\n        );\n    }\n}\n\n"}, "category": "Ink!", "tags": ["smart contract", "multisig"]}');

-- INSERT INTO questions (id, name, title, description, difficulty, frequency, rating, metadata)
-- VALUES ('111c5b2a-d704-11ed-afa1-0242ac120002', 'simple-auction', 'Simple Auction', 'Create a simple auction smart contract that allows users to bid on an item. Implement place_bid, withdraw, and finalize_auction functions. The contract should prevent bids after the auction has ended.', 'med', 45, 4.3, '{"starterCode": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod simple_auction {\n    #[ink(storage)]\n    pub struct SimpleAuction {\n        auction_end: Timestamp,\n        highest_bidder: AccountId,\n        highest_bid: Balance,\n    }\n    // Add your implementation here\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n    \n        use ink_lang as ink;\n    \n        #[ink::test]\n        fn test_place_bid() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // place a bid\n            let bidder = account_id_from_seed(&\"Alice\");\n            let value = 100;\n            assert_eq!(auction.place_bid().transact(bidder, value), Ok(()));\n            // check that the highest bidder and bid have been updated\n            assert_eq!(auction.highest_bidder(), Some(bidder));\n            assert_eq!(auction.highest_bid(), value);\n        }\n    \n        #[ink::test]\n        fn test_withdraw() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // place a bid\n            let bidder = account_id_from_seed(&\"Alice\");\n            let value = 100;\n            assert_eq!(auction.place_bid().transact(bidder, value), Ok(()));\n            // withdraw the bid\n            assert_eq!(auction.withdraw().transact(bidder, ()), Ok(()));\n            // check that the highest bidder and bid have been reset\n            assert_eq!(auction.highest_bidder(), None);\n            assert_eq!(auction.highest_bid(), 0);\n        }\n    \n        #[ink::test]\n        fn test_finalize_auction() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // place a bid\n            let bidder = account_id_from_seed(&\"Alice\");\n            let value = 100;\n            assert_eq!(auction.place_bid().transact(bidder, value), Ok(()));\n            // finalize the auction\n            assert_eq!(auction.finalize_auction().transact(bidder, ()), Ok(()));\n            // check that the highest bidder and bid have been reset\n            assert_eq!(auction.highest_bidder(), Some(bidder));\n            assert_eq!(auction.highest_bid(), value);\n        }\n    \n        #[ink::test]\n        fn test_place_bid_after_auction_end() {\n            // create a new auction ending in one second\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 1);\n            // wait for the auction to end\n            Self::env().test().advance_block_timestamp(2);\n            // place a bid\n            let bidder = account_id_from_seed(&\"Alice\");\n            let value = 100;\n            assert_eq!(\n                auction.place_bid().transact(bidder, value),\n                Err(Error::AuctionEnded)\n            );\n        }\n    \n        #[ink::test]\n        fn test_withdraw_before_bid() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // withdraw the bid\n            let bidder = account_id_from_seed(&\"Alice\");\n            assert_eq!(\n                auction.withdraw().transact(bidder, ()),\n                Err(Error::NoBidPlaced)\n            );\n        }\n    \n        #[ink::test]\n        fn test_finalize_auction_before_end() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // finalize the auction\n            let bidder = account_id_from_seed(&\"Alice\");\n            assert(\n                auction.finalize_auction().transact(bidder, ()),\n                Err(Error::AuctionNotEnded),\n            );\n        }\n\n        #[ink::test]\n        fn test_place_bid_lower_than_highest_bid() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // place a bid\n            let bidder1 = account_id_from_seed(&\"Alice\");\n            let value1 = 100;\n            assert_eq!(auction.place_bid().transact(bidder1, value1), Ok(()));\n            // place a lower bid\n            let bidder2 = account_id_from_seed(&\"Bob\");\n            let value2 = 50;\n            assert_eq!(\n                auction.place_bid().transact(bidder2, value2),\n                Err(Error::BidTooLow)\n            );\n        }\n        \n        #[ink::test]\n        fn test_finalize_auction_no_bids() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // finalize the auction\n            let bidder = account_id_from_seed(&\"Alice\");\n            assert_eq!(\n                auction.finalize_auction().transact(bidder, ()),\n                Err(Error::NoBidPlaced)\n            );\n        }\n    }\n}\n"}, "codeSolution": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\nuse ink_lang::contract;\nuse ink_prelude::vec::Vec;\nuse ink_prelude::collections::HashMap;\nuse ink_storage::collections::Vec as StorageVec;\nuse ink_storage::traits::{PackedLayout, SpreadLayout};\n\n#[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub enum Error {\n    AuctionEnded,\n    NoBidPlaced,\n    BidTooLow,\n    Unauthorized,\n}\n\n#[derive(Debug, PartialEq, Eq, Copy, Clone, scale::Encode, scale::Decode, SpreadLayout, PackedLayout)]\n#[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\npub struct Bid {\n    bidder: AccountId,\n    amount: Balance,\n}\n\n#[contract]\nmod simple_auction {\n    use super::*;\n\n    #[ink(storage)]\n    pub struct SimpleAuction {\n        owner: AccountId,\n        highest_bid: Balance,\n        highest_bidder: AccountId,\n        bids: StorageVec<Bid>,\n        auction_end: Timestamp,\n    }\n\n    impl SimpleAuction {\n        #[ink(constructor)]\n        pub fn new(auction_end: Timestamp) -> Self {\n            Self {\n                owner: Self::env().caller(),\n                highest_bid: 0,\n                highest_bidder: AccountId::default(),\n                bids: StorageVec::new(),\n                auction_end,\n            }\n        }\n\n        #[ink(message)]\n        pub fn place_bid(&mut self) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let value = self.env().transferred_balance();\n            if self.env().block_timestamp() >= self.auction_end {\n                return Err(Error::AuctionEnded);\n            }\n            if value <= self.highest_bid {\n                return Err(Error::BidTooLow);\n            }\n            self.bids.push(Bid { bidder: caller, amount: value });\n            self.highest_bid = value;\n            self.highest_bidder = caller;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn withdraw(&mut self) -> Result<(), Error> {\n            let caller = self.env().caller();\n            if self.env().block_timestamp() >= self.auction_end {\n                return Err(Error::AuctionEnded);\n            }\n            let bid_index = self.bids\n                .iter()\n                .position(|bid| bid.bidder == caller)\n                .ok_or(Error::NoBidPlaced)?;\n            let bid = self.bids.remove(bid_index);\n            if bid.amount == self.highest_bid {\n                self.highest_bid = self.bids.iter()\n                    .map(|bid| bid.amount)\n                    .max()\n                    .unwrap_or(0);\n                self.highest_bidder = self.bids.iter()\n                    .find(|bid| bid.amount == self.highest_bid)\n                    .map(|bid| bid.bidder)\n                    .unwrap_or(AccountId::default());\n            }\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn finalize_auction(&mut self) -> Result<(), Error> {\n            let caller = self.env().caller();\n            if caller != self.owner {\n                return Err(Error::Unauthorized);\n            }\n            if self.env().block_timestamp() < self.auction_end {\n                return Err(Error::AuctionNotEnded);\n            }\n            if let Some(bid) = self.bids.last() {\n                self.env().transfer(bid.bidder, bid.amount)\n                    .map_err(|_| Error::Unauthorized)?;\n            } else {\n                return Err(Error::NoBidPlaced);\n            }\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn highest_bidder(&self) -> Option<AccountId> {\n            if self.env().block_timestamp() < self.auction_end {\n                None\n            } else {\n                Some(self.highest_bidder)\n            }\n        }\n\n        #[ink(message)]\n        pub fn highest_bid(&self) -> Balance {\n            self.highest_bid\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n    \n        use ink_lang as ink;\n    \n        #[ink::test]\n        fn test_place_bid() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // place a bid\n            let bidder = account_id_from_seed(&\"Alice\");\n            let value = 100;\n            assert_eq!(auction.place_bid().transact(bidder, value), Ok(()));\n            // check that the highest bidder and bid have been updated\n            assert_eq!(auction.highest_bidder(), Some(bidder));\n            assert_eq!(auction.highest_bid(), value);\n        }\n    \n        #[ink::test]\n        fn test_withdraw() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // place a bid\n            let bidder = account_id_from_seed(&\"Alice\");\n            let value = 100;\n            assert_eq!(auction.place_bid().transact(bidder, value), Ok(()));\n            // withdraw the bid\n            assert_eq!(auction.withdraw().transact(bidder, ()), Ok(()));\n            // check that the highest bidder and bid have been reset\n            assert_eq!(auction.highest_bidder(), None);\n            assert_eq!(auction.highest_bid(), 0);\n        }\n    \n        #[ink::test]\n        fn test_finalize_auction() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // place a bid\n            let bidder = account_id_from_seed(&\"Alice\");\n            let value = 100;\n            assert_eq!(auction.place_bid().transact(bidder, value), Ok(()));\n            // finalize the auction\n            assert_eq!(auction.finalize_auction().transact(bidder, ()), Ok(()));\n            // check that the highest bidder and bid have been reset\n            assert_eq!(auction.highest_bidder(), Some(bidder));\n            assert_eq!(auction.highest_bid(), value);\n        }\n    \n        #[ink::test]\n        fn test_place_bid_after_auction_end() {\n            // create a new auction ending in one second\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 1);\n            // wait for the auction to end\n            Self::env().test().advance_block_timestamp(2);\n            // place a bid\n            let bidder = account_id_from_seed(&\"Alice\");\n            let value = 100;\n            assert_eq!(\n                auction.place_bid().transact(bidder, value),\n                Err(Error::AuctionEnded)\n            );\n        }\n    \n        #[ink::test]\n        fn test_withdraw_before_bid() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // withdraw the bid\n            let bidder = account_id_from_seed(&\"Alice\");\n            assert_eq!(\n                auction.withdraw().transact(bidder, ()),\n                Err(Error::NoBidPlaced)\n            );\n        }\n    \n        #[ink::test]\n        fn test_finalize_auction_before_end() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // finalize the auction\n            let bidder = account_id_from_seed(&\"Alice\");\n            assert(\n                auction.finalize_auction().transact(bidder, ()),\n                Err(Error::AuctionNotEnded),\n            );\n        }\n\n        #[ink::test]\n        fn test_place_bid_lower_than_highest_bid() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // place a bid\n            let bidder1 = account_id_from_seed(&\"Alice\");\n            let value1 = 100;\n            assert_eq!(auction.place_bid().transact(bidder1, value1), Ok(()));\n            // place a lower bid\n            let bidder2 = account_id_from_seed(&\"Bob\");\n            let value2 = 50;\n            assert_eq!(\n                auction.place_bid().transact(bidder2, value2),\n                Err(Error::BidTooLow)\n            );\n        }\n        \n        #[ink::test]\n        fn test_finalize_auction_no_bids() {\n            // create a new auction ending in one hour\n            let mut auction = SimpleAuction::new(Self::env().block_timestamp() + 3600);\n            // finalize the auction\n            let bidder = account_id_from_seed(&\"Alice\");\n            assert_eq!(\n                auction.finalize_auction().transact(bidder, ()),\n                Err(Error::NoBidPlaced)\n            );\n        }\n    }\n}\n"}, "category": "Ink!", "tags": ["smart contract", "auction"]}');
--
-- INSERT INTO questions (id, name, title, description, difficulty, frequency, rating, metadata)
-- VALUES ('524a87a2-d704-11ed-afa1-0242ac120002', 'timed-lock', 'Timed Lock', 'Create a timed lock smart contract that allows users to lock their funds for a specified duration. Implement lock, unlock, and get_remaining_time functions. The contract should prevent withdrawals before the lock duration has elapsed.', 'med', 35, 4.1, '{"starterCode": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod timed_lock {\n    #[ink(storage)]\n    pub struct TimedLock {\n        lock_duration: Timestamp,\n        lock_end: Timestamp,\n        locked_balance: Balance,\n        owner: AccountId,\n    }\n    // Add your implementation here\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n    \n        use ink_env::{\n            AccountId,\n            DefaultEnvironment,\n            Environment,\n            Hash,\n        };\n        use ink_lang as ink;\n        use ink_prelude::{string::String, vec::Vec};\n        use ink_storage::traits::{PackedLayout, SpreadLayout};\n    \n        type AccountId = <DefaultEnvironment as Environment>::AccountId;\n        type Balance = <DefaultEnvironment as Environment>::Balance;\n        type Timestamp = <DefaultEnvironment as Environment>::Timestamp;\n    \n        const ENDOWMENT: Balance = 1_000_000;\n        const MAX_GAS: u64 = 1_000_000;\n    \n        fn account_id_from_seed(seed: &str) -> AccountId {\n            let env = ink_env::test::TestEnvironment::new();\n            let callee = ink_env::account_id::<DefaultEnvironment>(ink_env::call::callee::<DefaultEnvironment>().unwrap());\n            let rand = ink_env::hash::Sha2x256::hash(seed.as_bytes());\n            let mut buf = [0u8; 32];\n            buf.copy_from_slice(&rand.as_fixed_bytes());\n            ink_env::test::CallBuilder::new(env.accounts.create().endowment(ENDOWMENT).build().create_call(\n                callee,\n                \"set_owner\",\n                ink_env::test::CallData::new(buf.to_vec()),\n            )).gas_limit(MAX_GAS).execute().expect(\"creating new account instance failed\").unwrap()\n        }\n    \n        #[ink::test]\n        fn test_lock() {\n            // create a new timed lock contract with a duration of 1 hour\n            let mut lock = TimedLock::new(Self::env().caller(), 3600);\n            // lock 100 tokens\n            let value = 100;\n            assert_eq!(lock.lock().transact(Self::env().caller(), value), Ok(()));\n            // check that the locked balance has increased\n            assert_eq!(lock.locked_balance(), value);\n        }\n    \n        #[ink::test]\n        fn test_unlock() {\n            // create a new timed lock contract with a duration of 1 hour\n            let mut lock = TimedLock::new(Self::env().caller(), 3600);\n            // lock 100 tokens\n            let value = 100;\n            assert_eq!(lock.lock().transact(Self::env().caller(), value), Ok(()));\n            // wait for the lock duration to expire\n            Self::env().test_set_timestamp(Self::env().block_timestamp() + 3600);\n            // unlock the tokens\n            assert_eq!(lock.unlock().transact(Self::env().caller(), ()), Ok(()));\n            // check that the locked balance has been cleared\n            assert_eq!(lock.locked_balance(), 0);\n        }\n    \n        #[ink::test]\n        fn test_get_remaining_time() {\n            // create a new timed lock contract with a duration of 1 hour\n            let mut lock = TimedLock::new(Self::env().caller(), 3600);\n            // check that the remaining time is initially 1 hour\n            assert_eq!(lock.get_remaining_time(), 3600);\n            // lock 100 tokens\n            let value = 100;\n            assert_eq!(lock.lock().transact(Self::env().caller(), value), Ok(()));\n            // check that the remaining time is still 1 hour\n            assert_eq!(lock.get_remaining_time(), 3600);\n            // wait for 30 minutes\n            Self::env().test_set_timestamp(Self::env().block_timestamp() + 1800);\n            // check that the remaining time is now 30 minutes\n            assert_eq!(lock.get_remaining_time(), 1800);\n            // wait for another 30 minutes\n            Self::env().test_set_timestamp(Self::env().block_timestamp() + 1800);\n            // check that the remaining time is now 0\n            assert_eq!(lock.get_remaining_time(), 0);\n        }\n    \n        #[ink::test]\n        fn test_unlock_before_duration_has_elapsed() {\n            // create a new timed lock contract with a duration of 1 hour\n            let mut lock = TimedLock::new(Self::env().caller(), 3600);\n            // lock 100 tokens\n            let value = 100;\n            assert_eq!(lock.lock().transact(Self::env().caller(), value), Ok(()));\n            // try to unlock the tokens before the lock duration has elapsed\n            assert_eq!(lock.unlock().transact(Self::env().caller(), ()), Err(Error::DurationNotElapsed));\n            // check that the locked balance has not been cleared\n            assert_eq!(lock.locked_balance(), value);\n        }\n    }\n}\n"}, "codeSolution": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod timed_lock {\n    use ink_prelude::vec::Vec;\n\n    #[ink(storage)]\n    pub struct TimedLock {\n        lock_duration: Timestamp,\n        lock_end: Timestamp,\n        locked_balance: Balance,\n        owner: AccountId,\n    }\n    \n\n    impl TimedLock {\n        #[ink(constructor)]\n        pub fn new(owner: AccountId, lock_duration: Timestamp) -> Self {\n            Self {\n                owner,\n                lock_duration,\n                ..Default::default()\n            }\n        }\n\n        #[ink(message)]\n        pub fn lock(&mut self) -> Result<(), Error> {\n            if self.locked_balance > 0 {\n                return Err(Error::AlreadyLocked);\n            }\n            let caller = self.env().caller();\n            let balance = self.env().balance_of(caller);\n            if balance == 0 {\n                return Err(Error::NoBalance);\n            }\n            self.locked_balance = balance;\n            self.lock_end = self.env().block_timestamp() + self.lock_duration;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn unlock(&mut self) -> Result<(), Error> {\n            if self.locked_balance == 0 {\n                return Err(Error::NotLocked);\n            }\n            if self.env().block_timestamp() < self.lock_end {\n                return Err(Error::DurationNotElapsed);\n            }\n            let caller = self.env().caller();\n            if caller != self.owner {\n                return Err(Error::NotAuthorized);\n            }\n            let balance = self.locked_balance;\n            self.locked_balance = 0;\n            self.env().transfer(caller, balance)?;\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn get_remaining_time(&self) -> Timestamp {\n            let now = self.env().block_timestamp();\n            if now >= self.lock_end {\n                return 0;\n            }\n            self.lock_end - now\n        }\n\n        #[ink(message)]\n        pub fn locked_balance(&self) -> Balance {\n            self.locked_balance\n        }\n    }\n\n    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n    #[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\n    pub enum Error {\n        AlreadyLocked,\n        NoBalance,\n        NotLocked,\n        DurationNotElapsed,\n        NotAuthorized,\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n    \n        use ink_env::{\n            AccountId,\n            DefaultEnvironment,\n            Environment,\n            Hash,\n        };\n        use ink_lang as ink;\n        use ink_prelude::{string::String, vec::Vec};\n        use ink_storage::traits::{PackedLayout, SpreadLayout};\n    \n        type AccountId = <DefaultEnvironment as Environment>::AccountId;\n        type Balance = <DefaultEnvironment as Environment>::Balance;\n        type Timestamp = <DefaultEnvironment as Environment>::Timestamp;\n    \n        const ENDOWMENT: Balance = 1_000_000;\n        const MAX_GAS: u64 = 1_000_000;\n    \n        fn account_id_from_seed(seed: &str) -> AccountId {\n            let env = ink_env::test::TestEnvironment::new();\n            let callee = ink_env::account_id::<DefaultEnvironment>(ink_env::call::callee::<DefaultEnvironment>().unwrap());\n            let rand = ink_env::hash::Sha2x256::hash(seed.as_bytes());\n            let mut buf = [0u8; 32];\n            buf.copy_from_slice(&rand.as_fixed_bytes());\n            ink_env::test::CallBuilder::new(env.accounts.create().endowment(ENDOWMENT).build().create_call(\n                callee,\n                \"set_owner\",\n                ink_env::test::CallData::new(buf.to_vec()),\n            )).gas_limit(MAX_GAS).execute().expect(\"creating new account instance failed\").unwrap()\n        }\n    \n        #[ink::test]\n        fn test_lock() {\n            // create a new timed lock contract with a duration of 1 hour\n            let mut lock = TimedLock::new(Self::env().caller(), 3600);\n            // lock 100 tokens\n            let value = 100;\n            assert_eq!(lock.lock().transact(Self::env().caller(), value), Ok(()));\n            // check that the locked balance has increased\n            assert_eq!(lock.locked_balance(), value);\n        }\n    \n        #[ink::test]\n        fn test_unlock() {\n            // create a new timed lock contract with a duration of 1 hour\n            let mut lock = TimedLock::new(Self::env().caller(), 3600);\n            // lock 100 tokens\n            let value = 100;\n            assert_eq!(lock.lock().transact(Self::env().caller(), value), Ok(()));\n            // wait for the lock duration to expire\n            Self::env().test_set_timestamp(Self::env().block_timestamp() + 3600);\n            // unlock the tokens\n            assert_eq!(lock.unlock().transact(Self::env().caller(), ()), Ok(()));\n            // check that the locked balance has been cleared\n            assert_eq!(lock.locked_balance(), 0);\n        }\n    \n        #[ink::test]\n        fn test_get_remaining_time() {\n            // create a new timed lock contract with a duration of 1 hour\n            let mut lock = TimedLock::new(Self::env().caller(), 3600);\n            // check that the remaining time is initially 1 hour\n            assert_eq!(lock.get_remaining_time(), 3600);\n            // lock 100 tokens\n            let value = 100;\n            assert_eq!(lock.lock().transact(Self::env().caller(), value), Ok(()));\n            // check that the remaining time is still 1 hour\n            assert_eq!(lock.get_remaining_time(), 3600);\n            // wait for 30 minutes\n            Self::env().test_set_timestamp(Self::env().block_timestamp() + 1800);\n            // check that the remaining time is now 30 minutes\n            assert_eq!(lock.get_remaining_time(), 1800);\n            // wait for another 30 minutes\n            Self::env().test_set_timestamp(Self::env().block_timestamp() + 1800);\n            // check that the remaining time is now 0\n            assert_eq!(lock.get_remaining_time(), 0);\n        }\n    \n        #[ink::test]\n        fn test_unlock_before_duration_has_elapsed() {\n            // create a new timed lock contract with a duration of 1 hour\n            let mut lock = TimedLock::new(Self::env().caller(), 3600);\n            // lock 100 tokens\n            let value = 100;\n            assert_eq!(lock.lock().transact(Self::env().caller(), value), Ok(()));\n            // try to unlock the tokens before the lock duration has elapsed\n            assert_eq!(lock.unlock().transact(Self::env().caller(), ()), Err(Error::DurationNotElapsed));\n            // check that the locked balance has not been cleared\n            assert_eq!(lock.locked_balance(), value);\n        }\n    }\n}\n"}, "category": "Ink!", "tags": ["smart contract", "timed lock"]}');
--
-- INSERT INTO questions (id, name, title, description, difficulty, frequency, rating, metadata)
-- VALUES ('9a3e20e6-d704-11ed-afa1-0242ac120002', 'erc20-token', 'ERC-20 Token', 'Create an ERC-20 compliant token smart contract that allows users to mint, transfer, and check their token balance. Implement the required functions according to the ERC-20 standard.', 'hard', 25, 4.9, '{"starterCode": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod erc20_token {\n    #[ink(storage)]\n    pub struct Erc20Token {\n        balances: ink_prelude::collections::HashMap<AccountId, Balance>,\n        allowances: ink_prelude::collections::HashMap<(AccountId, AccountId), Balance>,\n        total_supply: Balance,\n    }\n    // Add your implementation here\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n    \n        #[ink::test]\n        fn test_total_supply() {\n            let token = Erc20Token::new();\n            assert_eq!(token.total_supply(), 0);\n        }\n    \n        #[ink::test]\n        fn test_mint() {\n            let mut token = Erc20Token::new();\n            let account_id = AccountId::from([0x01; 32]);\n            let amount = 100;\n            token.mint(account_id, amount);\n            assert_eq!(token.total_supply(), amount);\n            assert_eq!(token.balance_of(account_id), amount);\n        }\n    \n        #[ink::test]\n        fn test_transfer() {\n            let mut token = Erc20Token::new();\n            let account_id1 = AccountId::from([0x01; 32]);\n            let account_id2 = AccountId::from([0x02; 32]);\n            let amount = 100;\n            token.mint(account_id1, amount);\n            assert_eq!(token.balance_of(account_id1), amount);\n            assert_eq!(token.balance_of(account_id2), 0);\n            token.transfer(account_id2, amount);\n            assert_eq!(token.balance_of(account_id1), 0);\n            assert_eq!(token.balance_of(account_id2), amount);\n        }\n    \n        #[ink::test]\n        fn test_transfer_insufficient_balance() {\n            let mut token = Erc20Token::new();\n            let account_id1 = AccountId::from([0x01; 32]);\n            let account_id2 = AccountId::from([0x02; 32]);\n            let amount = 100;\n            token.mint(account_id1, amount);\n            assert_eq!(token.balance_of(account_id1), amount);\n            assert_eq!(token.balance_of(account_id2), 0);\n            assert_eq!(\n                token.transfer(account_id2, amount + 1),\n                Err(Error::InsufficientBalance)\n            );\n            assert_eq!(token.balance_of(account_id1), amount);\n            assert_eq!(token.balance_of(account_id2), 0);\n        }\n    \n        #[ink::test]\n        fn test_approve() {\n            let mut token = Erc20Token::new();\n            let account_id1 = AccountId::from([0x01; 32]);\n            let account_id2 = AccountId::from([0x02; 32]);\n            let amount = 100;\n            token.mint(account_id1, amount);\n            assert_eq!(token.allowance(account_id1, account_id2), 0);\n            token.approve(account_id2, amount / 2);\n            assert_eq!(token.allowance(account_id1, account_id2), amount / 2);\n        }\n    \n        #[ink::test]\n        fn test_transfer_from() {\n            let mut token = Erc20Token::new();\n            let account_id1 = AccountId::from([0x01; 32]);\n            let account_id2 = AccountId::from([0x02; 32]);\n            let account_id3 = AccountId::from([0x03; 32]);\n            let amount = 100;\n            token.mint(account_id1, amount);\n            assert_eq!(token.balance_of(account_id1), amount);\n            assert_eq!(token.balance_of(account_id2), 0);\n            assert_eq!(token.allowance(account_id1, account_id3), 0);\n            token.approve(account_id3, amount / 2);\n            assert_eq!(token.allowance(account_id1, account_id3), amount / 2);\n            assert_eq!(\n                token.transfer_from(account_id1, account_id2, amount / 2, account_id3),\n                Ok(())\n            );\n            assert_eq!(token.balance_of(account_id1), amount / 2);\n            assert_eq!(token.balance_of(account_id2), amount / 2);\n            assert_eq!(token.allowance(account_id1, account_id3), 0);\n        }\n\n        #[ink::test]\n        fn test_transfer_from_insufficient_allowance() {\n            let mut token = Erc20Token::new();\n            let account_id1 = AccountId::from([0x01; 32]);\n            let account_id2 = AccountId::from([0x02; 32]);\n            let account_id3 = AccountId::from([0x03; 32]);\n            let amount = 100;\n            token.mint(account_id1, amount);\n            assert_eq!(token.balance_of(account_id1), amount);\n            assert_eq!(token.balance_of(account_id2), 0);\n            assert_eq!(token.allowance(account_id1, account_id3), 0);\n            token.approve(account_id3, amount / 2 - 1);\n            assert_eq!(token.allowance(account_id1, account_id3), amount / 2 - 1);\n            assert_eq!(\n                token.transfer_from(account_id1, account_id2, amount / 2, account_id3),\n                Err(Error::InsufficientAllowance)\n            );\n            assert_eq!(token.balance_of(account_id1), amount);\n            assert_eq!(token.balance_of(account_id2), 0);\n            assert_eq!(token.allowance(account_id1, account_id3), amount / 2 - 1);\n        }\n\n}\n"}, "codeSolution": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod erc20_token {\nuse ink_prelude::collections::HashMap;\n    use ink_storage::{\n        traits::{PackedLayout, SpreadLayout},\n        Lazy,\n    };\n\n    #[ink(storage)]\n    pub struct Erc20Token {\n        balances: HashMap<AccountId, Balance>,\n        allowances: HashMap<(AccountId, AccountId), Balance>,\n        total_supply: Balance,\n    }\n\n    #[ink(event)]\n    pub struct Transfer {\n        #[ink(topic)]\n        from: Option<AccountId>,\n        #[ink(topic)]\n        to: Option<AccountId>,\n        #[ink(topic)]\n        value: Balance,\n    }\n\n    #[ink(event)]\n    pub struct Approval {\n        #[ink(topic)]\n        owner: AccountId,\n        #[ink(topic)]\n        spender: AccountId,\n        #[ink(topic)]\n        value: Balance,\n    }\n\n    impl Erc20Token {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self {\n                balances: HashMap::new(),\n                allowances: HashMap::new(),\n                total_supply: 0,\n            }\n        }\n\n        #[ink(message)]\n        pub fn total_supply(&self) -> Balance {\n            self.total_supply\n        }\n\n        #[ink(message)]\n        pub fn balance_of(&self, account: AccountId) -> Balance {\n            self.balances.get(&account).copied().unwrap_or(0)\n        }\n\n        #[ink(message)]\n        pub fn allowance(&self, owner: AccountId, spender: AccountId) -> Balance {\n            self.allowances\n                .get(&(owner, spender))\n                .copied()\n                .unwrap_or(0)\n        }\n\n        #[ink(message)]\n        pub fn transfer(&mut self, to: AccountId, value: Balance) -> Result<(), Error> {\n            let from = self.env().caller();\n            self.transfer_internal(from, to, value)\n        }\n\n        #[ink(message)]\n        pub fn approve(&mut self, spender: AccountId, value: Balance) -> Result<(), Error> {\n            let owner = self.env().caller();\n            self.allowances.insert((owner, spender), value);\n            self.env()\n                .emit_event(Approval {\n                    owner,\n                    spender,\n                    value,\n                });\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn transfer_from(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n            caller: AccountId,\n        ) -> Result<(), Error> {\n            let allowance = self.allowance(from, caller);\n            if allowance < value {\n                return Err(Error::InsufficientAllowance);\n            }\n            let balance = self.balance_of(from);\n            if balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.allowances.insert((from, caller), allowance - value);\n            self.transfer_internal(from, to, value)?;\n            Ok(())\n        }\n\n        fn transfer_internal(\n            &mut self,\n            from: AccountId,\n            to: AccountId,\n            value: Balance,\n        ) -> Result<(), Error> {\n            if from == to {\n                return Ok(());\n            }\n            let from_balance = self.balance_of(from);\n            if from_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            let to_balance = self.balance_of(to);\n            self.balances.insert(from, from_balance - value);\n            self.balances.insert(to, to_balance + value);\n            self.env().emit_event(Transfer {\n                from: Some(from),\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn mint(&mut self, to: AccountId, value: Balance) -> Result<(), Error> {\n            let caller = self.env().caller();\n            self.check_owner(caller)?;\n            self.total_supply = self.total_supply.checked_add(value).ok_or(Error::ArithmeticOverflow)?;\n            let to_balance = self.balance_of(to);\n            self.balances.insert(to, to_balance + value);\n            self.env().emit_event(Transfer {\n                from: None,\n                to: Some(to),\n                value,\n            });\n            Ok(())\n        }\n    \n        #[ink(message)]\n        pub fn burn(&mut self, value: Balance) -> Result<(), Error> {\n            let caller = self.env().caller();\n            let caller_balance = self.balance_of(caller);\n            if caller_balance < value {\n                return Err(Error::InsufficientBalance);\n            }\n            self.total_supply = self.total_supply.checked_sub(value).ok_or(Error::ArithmeticUnderflow)?;\n            self.balances.insert(caller, caller_balance - value);\n            self.env().emit_event(Transfer {\n                from: Some(caller),\n                to: None,\n                value,\n            });\n            Ok(())\n        }\n    \n        fn check_owner(&self, owner: AccountId) -> Result<(), Error> {\n            if !self.is_owner(owner) {\n                return Err(Error::NotOwner);\n            }\n            Ok(())\n        }\n    \n        fn is_owner(&self, account: AccountId) -> bool {\n            self.env().caller() == account\n        }\n    }\n\n    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n    #[cfg_attr(feature = \"std\", derive(scale_info::TypeInfo))]\n    pub enum Error {\n        InsufficientBalance,\n        InsufficientAllowance,\n        ArithmeticOverflow,\n        ArithmeticUnderflow,\n        NotOwner,\n    }\n    \n    impl ink::chain::block::BlockNumberProvider for Erc20Token {\n        type BlockNumber = ink_env::chain::block::BlockNumber;\n    \n        fn block_number(&self) -> Self::BlockNumber {\n            ink_env::block_number::<ink_env::DefaultEnvironment>().unwrap_or(0)\n        }\n    }\n\n    #[cfg(test)]\n    mod tests {\n        use super::*;\n    \n        #[ink::test]\n        fn test_total_supply() {\n            let token = Erc20Token::new();\n            assert_eq!(token.total_supply(), 0);\n        }\n    \n        #[ink::test]\n        fn test_mint() {\n            let mut token = Erc20Token::new();\n            let account_id = AccountId::from([0x01; 32]);\n            let amount = 100;\n            token.mint(account_id, amount);\n            assert_eq!(token.total_supply(), amount);\n            assert_eq!(token.balance_of(account_id), amount);\n        }\n    \n        #[ink::test]\n        fn test_transfer() {\n            let mut token = Erc20Token::new();\n            let account_id1 = AccountId::from([0x01; 32]);\n            let account_id2 = AccountId::from([0x02; 32]);\n            let amount = 100;\n            token.mint(account_id1, amount);\n            assert_eq!(token.balance_of(account_id1), amount);\n            assert_eq!(token.balance_of(account_id2), 0);\n            token.transfer(account_id2, amount);\n            assert_eq!(token.balance_of(account_id1), 0);\n            assert_eq!(token.balance_of(account_id2), amount);\n        }\n    \n        #[ink::test]\n        fn test_transfer_insufficient_balance() {\n            let mut token = Erc20Token::new();\n            let account_id1 = AccountId::from([0x01; 32]);\n            let account_id2 = AccountId::from([0x02; 32]);\n            let amount = 100;\n            token.mint(account_id1, amount);\n            assert_eq!(token.balance_of(account_id1), amount);\n            assert_eq!(token.balance_of(account_id2), 0);\n            assert_eq!(\n                token.transfer(account_id2, amount + 1),\n                Err(Error::InsufficientBalance)\n            );\n            assert_eq!(token.balance_of(account_id1), amount);\n            assert_eq!(token.balance_of(account_id2), 0);\n        }\n    \n        #[ink::test]\n        fn test_approve() {\n            let mut token = Erc20Token::new();\n            let account_id1 = AccountId::from([0x01; 32]);\n            let account_id2 = AccountId::from([0x02; 32]);\n            let amount = 100;\n            token.mint(account_id1, amount);\n            assert_eq!(token.allowance(account_id1, account_id2), 0);\n            token.approve(account_id2, amount / 2);\n            assert_eq!(token.allowance(account_id1, account_id2), amount / 2);\n        }\n    \n        #[ink::test]\n        fn test_transfer_from() {\n            let mut token = Erc20Token::new();\n            let account_id1 = AccountId::from([0x01; 32]);\n            let account_id2 = AccountId::from([0x02; 32]);\n            let account_id3 = AccountId::from([0x03; 32]);\n            let amount = 100;\n            token.mint(account_id1, amount);\n            assert_eq!(token.balance_of(account_id1), amount);\n            assert_eq!(token.balance_of(account_id2), 0);\n            assert_eq!(token.allowance(account_id1, account_id3), 0);\n            token.approve(account_id3, amount / 2);\n            assert_eq!(token.allowance(account_id1, account_id3), amount / 2);\n            assert_eq!(\n                token.transfer_from(account_id1, account_id2, amount / 2, account_id3),\n                Ok(())\n            );\n            assert_eq!(token.balance_of(account_id1), amount / 2);\n            assert_eq!(token.balance_of(account_id2), amount / 2);\n            assert_eq!(token.allowance(account_id1, account_id3), 0);\n        }\n\n        #[ink::test]\n        fn test_transfer_from_insufficient_allowance() {\n            let mut token = Erc20Token::new();\n            let account_id1 = AccountId::from([0x01; 32]);\n            let account_id2 = AccountId::from([0x02; 32]);\n            let account_id3 = AccountId::from([0x03; 32]);\n            let amount = 100;\n            token.mint(account_id1, amount);\n            assert_eq!(token.balance_of(account_id1), amount);\n            assert_eq!(token.balance_of(account_id2), 0);\n            assert_eq!(token.allowance(account_id1, account_id3), 0);\n            token.approve(account_id3, amount / 2 - 1);\n            assert_eq!(token.allowance(account_id1, account_id3), amount / 2 - 1);\n            assert_eq!(\n                token.transfer_from(account_id1, account_id2, amount / 2, account_id3),\n                Err(Error::InsufficientAllowance)\n            );\n            assert_eq!(token.balance_of(account_id1), amount);\n            assert_eq!(token.balance_of(account_id2), 0);\n            assert_eq!(token.allowance(account_id1, account_id3), amount / 2 - 1);\n        }\n\n}\n"}, "category": "Ink!", "tags": ["smart contract", "erc20"]}');
--
-- INSERT INTO questions (id, name, title, description, difficulty, frequency, rating, metadata)
-- VALUES ('e2ceeb1a-d704-11ed-afa1-0242ac120002', 'decentralized-oracle', 'Decentralized Oracle', 'Create a decentralized oracle smart contract that allows users to request external data and receive it within the contract. Implement request_data, provide_data, and get_data functions.', 'hard', 15, 5, '{"starterCode": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod decentralized_oracle {\n    #[ink(storage)]\n    pub struct DecentralizedOracle {\n        data_requests: ink_prelude::collections::HashMap<String, Balance>,\n        data_providers: ink_prelude::collections::HashMap<AccountId, bool>,\n    }\n    // Add your implementation here\n\n    #[cfg(test)]\n    mod tests {\n\n        #[ink::test]\n        fn test_request_and_provide_data() {\n            // set up\n            let mut oracle = DecentralizedOracle::new();\n            let data_id = \"BTC/USD\".to_string();\n            let requester = AccountId::new([1; 32]);\n            let provider = AccountId::new([2; 32]);\n            let reward = 1000;\n    \n            // request data\n            assert!(oracle.request_data(data_id.clone(), reward).is_ok());\n            assert_eq!(\n                oracle.data_requests.get(&data_id),\n                Some(&(requester, reward))\n            );\n    \n            // provide data - wrong data ID\n            assert_eq!(\n                oracle.provide_data(\"ETH/USD\".to_string(), vec![0; 32]),\n                Err(Error::DataIdNotFound)\n            );\n            assert_eq!(\n                oracle.data_requests.get(&data_id),\n                Some(&(requester, reward))\n            );\n    \n            // provide data - wrong provider\n            assert_eq!(\n                oracle.provide_data(data_id.clone(), vec![0; 32]),\n                Err(Error::DataProviderAlreadyExists)\n            );\n            assert_eq!(\n                oracle.data_requests.get(&data_id),\n                Some(&(requester, reward))\n            );\n    \n            // provide data - correct data ID and provider\n            assert!(oracle.provide_data(data_id.clone(), vec![0; 32]).is_ok());\n            assert_eq!(oracle.data_results.get(&data_id), Some(&vec![0; 32]));\n            assert_eq!(oracle.data_requests.get(&data_id), None);\n            assert_eq!(oracle.data_providers.get(&provider), Some(&true));\n            assert!(oracle.data_providers.get(&requester).is_none());\n    \n            // provide data - transfer failed\n            assert_eq!(\n                oracle.provide_data(data_id.clone(), vec![0; 32]),\n                Err(Error::TransferFailed)\n            );\n            assert_eq!(oracle.data_results.get(&data_id), Some(&vec![0; 32]));\n            assert_eq!(oracle.data_requests.get(&data_id), None);\n            assert_eq!(oracle.data_providers.get(&provider), Some(&true));\n            assert!(oracle.data_providers.get(&requester).is_none());\n        }\n    \n        #[ink::test]\n        fn test_get_data() {\n            // set up\n            let mut oracle = DecentralizedOracle::new();\n            let data_id = \"BTC/USD\".to_string();\n            let requester = AccountId::new([1; 32]);\n            let provider = AccountId::new([2; 32]);\n            let reward = 1000;\n    \n            // request and provide data\n            oracle.request_data(data_id.clone(), reward).unwrap();\n            oracle.provide_data(data_id.clone(), vec![1; 32]).unwrap();\n    \n            // get data - wrong provider\n            assert_eq!(\n                oracle.get_data(data_id.clone(), { AccountId::new([3; 32]) }),\n                Err(Error::NotAuthorized)\n            );\n    \n            // get data - wrong data ID\n            assert_eq!(\n                oracle.get_data(\"ETH/USD\".to_string(), provider),\n                Err(Error::DataIdNotFound)\n            );\n    \n            // get data - correct data ID and provider\n            assert_eq!(\n                oracle.get_data(data_id.clone(), provider).unwrap(),\n                vec![1; 32]\n            );\n            assert!(oracle.data_requests.get(&data_id).is_none());\n            assert!(oracle.data_providers.get(&provider).is_some());\n            assert!(oracle.data_providers.get(&requester).is_none());\n        }\n    }\n}\n"}, "codeSolution": {"substrate_rust": "#![cfg_attr(not(feature = \"std\"), no_std)]\n\nuse ink_lang as ink;\n\n#[ink::contract]\nmod decentralized_oracle {\n    use ink_prelude::vec::Vec;\n\n    #[ink(storage)]\n    pub struct DecentralizedOracle {\n        data_requests: ink_prelude::collections::HashMap<String, (AccountId, Balance)>,\n        data_providers: ink_prelude::collections::HashMap<AccountId, bool>,\n        data_results: ink_prelude::collections::HashMap<String, Vec<u8>>,\n    }\n\n    impl DecentralizedOracle {\n        #[ink(constructor)]\n        pub fn new() -> Self {\n            Self {\n                data_requests: ink_prelude::collections::HashMap::new(),\n                data_providers: ink_prelude::collections::HashMap::new(),\n                data_results: ink_prelude::collections::HashMap::new(),\n            }\n        }\n\n        #[ink(message)]\n        pub fn request_data(&mut self, data_id: String, reward: Balance) -> Result<(), Error> {\n            if self.data_requests.contains_key(&data_id) {\n                return Err(Error::DataIdAlreadyExists);\n            }\n\n            let requester = Self::env().caller();\n            self.data_requests.insert(data_id, (requester, reward));\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn provide_data(&mut self, data_id: String, data: Vec<u8>) -> Result<(), Error> {\n            let provider = Self::env().caller();\n            if !self.data_requests.contains_key(&data_id) {\n                return Err(Error::DataIdNotFound);\n            }\n            if self.data_providers.contains_key(&provider) {\n                return Err(Error::DataProviderAlreadyExists);\n            }\n\n            let (requester, reward) = self.data_requests.get(&data_id).unwrap();\n            if *reward > Self::env().transferred_balance() {\n                return Err(Error::InsufficientFunds);\n            }\n\n            self.data_results.insert(data_id.clone(), data);\n            self.data_requests.remove(&data_id);\n            self.data_providers.insert(provider, true);\n            if !Self::env().transfer(*requester, *reward) {\n                return Err(Error::TransferFailed);\n            }\n\n            Ok(())\n        }\n\n        #[ink(message)]\n        pub fn get_data(&self, data_id: String, provider: AccountId) -> Result<Vec<u8>, Error> {\n            if !self.data_results.contains_key(&data_id) {\n                return Err(Error::DataIdNotFound);\n            }\n            if !self.data_providers.contains_key(&provider) {\n                return Err(Error::NotAuthorized);\n            }\n\n            Ok(self.data_results.get(&data_id).unwrap().clone())\n        }\n    }\n\n    #[derive(Debug, PartialEq, Eq, scale::Encode, scale::Decode)]\n    #[cfg_attr(feature = \"std\", derive(Debug))]\n    pub enum Error {\n        DataIdNotFound,\n        DataIdAlreadyExists,\n        DataProviderAlreadyExists,\n        NotAuthorized,\n        InsufficientFunds,\n        TransferFailed,\n    }\n\n    #[cfg(test)]\n    mod tests {\n\n        #[ink::test]\n        fn test_request_and_provide_data() {\n            // set up\n            let mut oracle = DecentralizedOracle::new();\n            let data_id = \"BTC/USD\".to_string();\n            let requester = AccountId::new([1; 32]);\n            let provider = AccountId::new([2; 32]);\n            let reward = 1000;\n    \n            // request data\n            assert!(oracle.request_data(data_id.clone(), reward).is_ok());\n            assert_eq!(\n                oracle.data_requests.get(&data_id),\n                Some(&(requester, reward))\n            );\n    \n            // provide data - wrong data ID\n            assert_eq!(\n                oracle.provide_data(\"ETH/USD\".to_string(), vec![0; 32]),\n                Err(Error::DataIdNotFound)\n            );\n            assert_eq!(\n                oracle.data_requests.get(&data_id),\n                Some(&(requester, reward))\n            );\n    \n            // provide data - wrong provider\n            assert_eq!(\n                oracle.provide_data(data_id.clone(), vec![0; 32]),\n                Err(Error::DataProviderAlreadyExists)\n            );\n            assert_eq!(\n                oracle.data_requests.get(&data_id),\n                Some(&(requester, reward))\n            );\n    \n            // provide data - correct data ID and provider\n            assert!(oracle.provide_data(data_id.clone(), vec![0; 32]).is_ok());\n            assert_eq!(oracle.data_results.get(&data_id), Some(&vec![0; 32]));\n            assert_eq!(oracle.data_requests.get(&data_id), None);\n            assert_eq!(oracle.data_providers.get(&provider), Some(&true));\n            assert!(oracle.data_providers.get(&requester).is_none());\n    \n            // provide data - transfer failed\n            assert_eq!(\n                oracle.provide_data(data_id.clone(), vec![0; 32]),\n                Err(Error::TransferFailed)\n            );\n            assert_eq!(oracle.data_results.get(&data_id), Some(&vec![0; 32]));\n            assert_eq!(oracle.data_requests.get(&data_id), None);\n            assert_eq!(oracle.data_providers.get(&provider), Some(&true));\n            assert!(oracle.data_providers.get(&requester).is_none());\n        }\n    \n        #[ink::test]\n        fn test_get_data() {\n            // set up\n            let mut oracle = DecentralizedOracle::new();\n            let data_id = \"BTC/USD\".to_string();\n            let requester = AccountId::new([1; 32]);\n            let provider = AccountId::new([2; 32]);\n            let reward = 1000;\n    \n            // request and provide data\n            oracle.request_data(data_id.clone(), reward).unwrap();\n            oracle.provide_data(data_id.clone(), vec![1; 32]).unwrap();\n    \n            // get data - wrong provider\n            assert_eq!(\n                oracle.get_data(data_id.clone(), { AccountId::new([3; 32]) }),\n                Err(Error::NotAuthorized)\n            );\n    \n            // get data - wrong data ID\n            assert_eq!(\n                oracle.get_data(\"ETH/USD\".to_string(), provider),\n                Err(Error::DataIdNotFound)\n            );\n    \n            // get data - correct data ID and provider\n            assert_eq!(\n                oracle.get_data(data_id.clone(), provider).unwrap(),\n                vec![1; 32]\n            );\n            assert!(oracle.data_requests.get(&data_id).is_none());\n            assert!(oracle.data_providers.get(&provider).is_some());\n            assert!(oracle.data_providers.get(&requester).is_none());\n        }\n    }\n}\n"}, "category": "Ink!", "tags": ["smart contract", "decentralized oracle"]}');
